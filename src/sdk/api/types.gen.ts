// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

/**
 * AccessSchema
 */
export type AccessSchema = {
    /**
     * Map access type determining movement and accessibility
     */
    type: MapAccessType;
    /**
     * Conditions
     *
     * Access conditions for the map
     */
    conditions?: Array<ConditionSchema>;
};

/**
 * AccountAchievementSchema
 */
export type AccountAchievementSchema = {
    /**
     * Name
     *
     * Name of the achievement.
     */
    name: string;
    /**
     * Code
     *
     * Code of the achievement.
     */
    code: string;
    /**
     * Description
     *
     * Description of the achievement.
     */
    description: string;
    /**
     * Points
     *
     * Points of the achievement. Used for the leaderboard.
     */
    points: number;
    /**
     * Type of achievement.
     */
    type: AchievementType;
    /**
     * Target
     *
     * Target of the achievement.
     */
    target?: string;
    /**
     * Total
     *
     * Total to do.
     */
    total: number;
    /**
     * Rewards.
     */
    rewards: AchievementRewardsSchema;
    /**
     * Current
     *
     * Current progress.
     */
    current: number;
    /**
     * Completed At
     *
     * Completed at.
     */
    completed_at?: string;
};

/**
 * AccountDetails
 */
export type AccountDetails = {
    /**
     * Username
     *
     * Username.
     */
    username: string;
    /**
     * Member
     *
     * Member status.
     */
    member: boolean;
    /**
     * Account status.
     */
    status: AccountStatus;
    /**
     * Badges
     *
     * Account badges.
     */
    badges?: Array<string>;
    /**
     * Skins
     *
     * Skins owned.
     */
    skins: Array<string>;
    /**
     * Achievements Points
     *
     * Achievement points.
     */
    achievements_points: number;
    /**
     * Banned
     *
     * Banned.
     */
    banned: boolean;
    /**
     * Ban Reason
     *
     * Ban reason.
     */
    ban_reason?: string;
};

/**
 * AccountDetailsSchema
 */
export type AccountDetailsSchema = {
    data: AccountDetails;
};

/**
 * AccountLeaderboardSchema
 */
export type AccountLeaderboardSchema = {
    /**
     * Position
     *
     * Position in the leaderboard.
     */
    position: number;
    /**
     * Account
     *
     * Account name.
     */
    account: string;
    /**
     * Member status.
     */
    status: AccountStatus;
    /**
     * Achievements Points
     *
     * Achievements points.
     */
    achievements_points: number;
    /**
     * Gold
     *
     * Gold in the account.
     */
    gold: number;
};

/**
 * AccountLeaderboardType
 */
export type AccountLeaderboardType = 'achievements_points' | 'gold';

/**
 * AccountStatus
 */
export type AccountStatus = 'standard' | 'founder' | 'gold_founder' | 'vip_founder';

/**
 * AchievementResponseSchema
 */
export type AchievementResponseSchema = {
    data: AchievementSchema;
};

/**
 * AchievementRewardsSchema
 */
export type AchievementRewardsSchema = {
    /**
     * Gold
     *
     * Gold rewards.
     */
    gold: number;
};

/**
 * AchievementSchema
 */
export type AchievementSchema = {
    /**
     * Name
     *
     * Name of the achievement.
     */
    name: string;
    /**
     * Code
     *
     * Code of the achievement.
     */
    code: string;
    /**
     * Description
     *
     * Description of the achievement.
     */
    description: string;
    /**
     * Points
     *
     * Points of the achievement. Used for the leaderboard.
     */
    points: number;
    /**
     * Type of achievement.
     */
    type: AchievementType;
    /**
     * Target
     *
     * Target of the achievement.
     */
    target?: string;
    /**
     * Total
     *
     * Total to do.
     */
    total: number;
    /**
     * Rewards.
     */
    rewards: AchievementRewardsSchema;
};

/**
 * AchievementType
 */
export type AchievementType = 'combat_kill' | 'combat_drop' | 'combat_level' | 'gathering' | 'crafting' | 'recycling' | 'task' | 'other' | 'use';

/**
 * ActionType
 */
export type ActionType = 'movement' | 'fight' | 'multi_fight' | 'crafting' | 'gathering' | 'buy_ge' | 'sell_ge' | 'buy_npc' | 'sell_npc' | 'cancel_ge' | 'delete_item' | 'deposit_item' | 'withdraw_item' | 'deposit_gold' | 'withdraw_gold' | 'equip' | 'unequip' | 'task' | 'recycling' | 'rest' | 'use' | 'buy_bank_expansion' | 'give_item' | 'give_gold' | 'change_skin' | 'rename' | 'transition';

/**
 * ActiveCharacterSchema
 */
export type ActiveCharacterSchema = {
    /**
     * Name
     *
     * Name of the character.
     */
    name: string;
    /**
     * Account
     *
     * Account name.
     */
    account: string;
    /**
     * Character skin code.
     */
    skin: CharacterSkin;
    /**
     * X
     *
     * Character x coordinate.
     */
    x: number;
    /**
     * Y
     *
     * Character y coordinate.
     */
    y: number;
    /**
     * Character current layer.
     */
    layer: MapLayer;
    /**
     * Map Id
     *
     * Character current map ID.
     */
    map_id: number;
};

/**
 * ActiveEventResponseSchema
 */
export type ActiveEventResponseSchema = {
    data: ActiveEventSchema;
};

/**
 * ActiveEventSchema
 */
export type ActiveEventSchema = {
    /**
     * Name
     *
     * Name of the event.
     */
    name: string;
    /**
     * Code
     *
     * Code of the event.
     */
    code: string;
    /**
     * Map of the event.
     */
    map: MapSchema;
    /**
     * Previous map skin.
     */
    previous_map: MapSchema;
    /**
     * Duration
     *
     * Duration in minutes.
     */
    duration: number;
    /**
     * Expiration
     *
     * Expiration datetime.
     */
    expiration: string;
    /**
     * Created At
     *
     * Start datetime.
     */
    created_at: string;
};

/**
 * AddAccountSchema
 */
export type AddAccountSchema = {
    /**
     * Username
     *
     * Your desired username.
     */
    username: string;
    /**
     * Password
     *
     * Your password.
     */
    password: string;
    /**
     * Email
     *
     * Your email.
     */
    email: string;
};

/**
 * AddCharacterSchema
 */
export type AddCharacterSchema = {
    /**
     * Name
     *
     * Your desired character name. It's unique and all players can see it.
     */
    name: string;
    /**
     * Your desired skin. Skins unlocked by default: 'men1', 'men2', 'men3', 'women1', 'women2', 'women3'.
     */
    skin: CharacterSkin;
};

/**
 * BadgeConditionSchema
 */
export type BadgeConditionSchema = {
    /**
     * Code
     *
     * Code of the condition.
     */
    code: string;
    /**
     * Quantity
     *
     * Quantity of the condition (if any).
     */
    quantity?: number;
};

/**
 * BadgeResponseSchema
 */
export type BadgeResponseSchema = {
    data: BadgeSchema;
};

/**
 * BadgeSchema
 */
export type BadgeSchema = {
    /**
     * Code
     *
     * Code of the badge. This is the badge's unique identifier (ID).
     */
    code: string;
    /**
     * Season
     *
     * Season of the badge.
     */
    season?: number;
    /**
     * Description
     *
     * Description of the badge.
     */
    description: string;
    /**
     * Conditions
     *
     * Conditions to get the badge.
     */
    conditions: Array<BadgeConditionSchema>;
};

/**
 * BankExtensionSchema
 */
export type BankExtensionSchema = {
    /**
     * Price
     *
     * Price of the bank extension.
     */
    price: number;
};

/**
 * BankExtensionTransactionResponseSchema
 */
export type BankExtensionTransactionResponseSchema = {
    data: BankExtensionTransactionSchema;
};

/**
 * BankExtensionTransactionSchema
 */
export type BankExtensionTransactionSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Transaction details.
     */
    transaction: BankExtensionSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * BankGoldTransactionResponseSchema
 */
export type BankGoldTransactionResponseSchema = {
    data: BankGoldTransactionSchema;
};

/**
 * BankGoldTransactionSchema
 */
export type BankGoldTransactionSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Bank details.
     */
    bank: GoldSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * BankItemTransactionResponseSchema
 */
export type BankItemTransactionResponseSchema = {
    data: BankItemTransactionSchema;
};

/**
 * BankItemTransactionSchema
 */
export type BankItemTransactionSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Items
     *
     * Items details.
     */
    items: Array<SimpleItemSchema>;
    /**
     * Bank
     *
     * Items in your banks.
     */
    bank: Array<SimpleItemSchema>;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * BankResponseSchema
 */
export type BankResponseSchema = {
    data: BankSchema;
};

/**
 * BankSchema
 */
export type BankSchema = {
    /**
     * Slots
     *
     * Maximum slots in your bank.
     */
    slots: number;
    /**
     * Expansions
     *
     * Bank expansions.
     */
    expansions: number;
    /**
     * Next Expansion Cost
     *
     * Next expansion cost.
     */
    next_expansion_cost: number;
    /**
     * Gold
     *
     * Quantity of gold in your bank.
     */
    gold: number;
};

/**
 * ChangePassword
 */
export type ChangePassword = {
    /**
     * Current Password
     *
     * Your password.
     */
    current_password: string;
    /**
     * New Password
     *
     * New password.
     */
    new_password: string;
};

/**
 * ChangeSkinCharacterDataSchema
 */
export type ChangeSkinCharacterDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Skin
     *
     * Craft details.
     */
    skin: string;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * ChangeSkinCharacterSchema
 */
export type ChangeSkinCharacterSchema = {
    /**
     * Your desired skin. Skins unlocked by default: 'men1', 'men2', 'men3', 'women1', 'women2', 'women3'.
     */
    skin: CharacterSkin;
};

/**
 * ChangeSkinResponseSchema
 */
export type ChangeSkinResponseSchema = {
    data: ChangeSkinCharacterDataSchema;
};

/**
 * CharacterFightDataSchema
 */
export type CharacterFightDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Character fight details.
     */
    fight: CharacterFightSchema;
    /**
     * Characters
     *
     * All characters involved.
     */
    characters: Array<CharacterSchema>;
};

/**
 * CharacterFightResponseSchema
 */
export type CharacterFightResponseSchema = {
    data: CharacterFightDataSchema;
};

/**
 * CharacterFightSchema
 */
export type CharacterFightSchema = {
    /**
     * The result of the fight.
     */
    result: FightResult;
    /**
     * Turns
     *
     * Numbers of the turns of the combat.
     */
    turns: number;
    /**
     * Opponent
     *
     * The code of the monster fought.
     */
    opponent: string;
    /**
     * Logs
     *
     * The fight logs.
     */
    logs: Array<string>;
    /**
     * Characters
     *
     * Results for each character.
     */
    characters: Array<CharacterMultiFightResultSchema>;
};

/**
 * CharacterLeaderboardSchema
 */
export type CharacterLeaderboardSchema = {
    /**
     * Position
     *
     * Position in the leaderboard.
     */
    position: number;
    /**
     * Name
     *
     * Character name.
     */
    name: string;
    /**
     * Account
     *
     * Account name.
     */
    account: string;
    /**
     * Member status.
     */
    status: AccountStatus;
    /**
     * Skin
     *
     * Character skin code.
     */
    skin: string;
    /**
     * Level
     *
     * Combat level.
     */
    level: number;
    /**
     * Total Xp
     *
     * Total XP of your character.
     */
    total_xp: number;
    /**
     * Mining Level
     *
     * Mining level.
     */
    mining_level: number;
    /**
     * Mining Total Xp
     *
     * Mining total xp.
     */
    mining_total_xp: number;
    /**
     * Woodcutting Level
     *
     * Woodcutting level.
     */
    woodcutting_level: number;
    /**
     * Woodcutting Total Xp
     *
     * Woodcutting total xp.
     */
    woodcutting_total_xp: number;
    /**
     * Fishing Level
     *
     * Fishing level.
     */
    fishing_level: number;
    /**
     * Fishing Total Xp
     *
     * Fishing total xp.
     */
    fishing_total_xp: number;
    /**
     * Weaponcrafting Level
     *
     * Weaponcrafting level.
     */
    weaponcrafting_level: number;
    /**
     * Weaponcrafting Total Xp
     *
     * Weaponcrafting total xp.
     */
    weaponcrafting_total_xp: number;
    /**
     * Gearcrafting Level
     *
     * Gearcrafting level.
     */
    gearcrafting_level: number;
    /**
     * Gearcrafting Total Xp
     *
     * Gearcrafting total xp.
     */
    gearcrafting_total_xp: number;
    /**
     * Jewelrycrafting Level
     *
     * Jewelrycrafting level.
     */
    jewelrycrafting_level: number;
    /**
     * Jewelrycrafting Total Xp
     *
     * Jewelrycrafting total xp.
     */
    jewelrycrafting_total_xp: number;
    /**
     * Cooking Level
     *
     * Cooking level.
     */
    cooking_level: number;
    /**
     * Cooking Total Xp
     *
     * Cooking total xp.
     */
    cooking_total_xp: number;
    /**
     * Alchemy Level
     *
     * Alchemy level.
     */
    alchemy_level: number;
    /**
     * Alchemy Total Xp
     *
     * Alchemy total xp.
     */
    alchemy_total_xp: number;
    /**
     * Gold
     *
     * The numbers of gold on this character.
     */
    gold: number;
};

/**
 * CharacterLeaderboardType
 */
export type CharacterLeaderboardType = 'combat' | 'woodcutting' | 'mining' | 'fishing' | 'weaponcrafting' | 'gearcrafting' | 'jewelrycrafting' | 'cooking' | 'alchemy';

/**
 * CharacterMovementDataSchema
 */
export type CharacterMovementDataSchema = {
    /**
     * Cooldown details
     */
    cooldown: CooldownSchema;
    /**
     * Destination details.
     */
    destination: MapSchema;
    /**
     * Path
     *
     * Path taken from start to destination (list of coordinates)
     */
    path: Array<[
        number,
        number
    ]>;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * CharacterMovementResponseSchema
 */
export type CharacterMovementResponseSchema = {
    data: CharacterMovementDataSchema;
};

/**
 * CharacterMultiFightResultSchema
 */
export type CharacterMultiFightResultSchema = {
    /**
     * Character Name
     *
     * Name of the character.
     */
    character_name: string;
    /**
     * Xp
     *
     * XP gained by this character.
     */
    xp: number;
    /**
     * Gold
     *
     * Gold gained by this character.
     */
    gold: number;
    /**
     * Drops
     *
     * Items dropped for this character.
     */
    drops: Array<DropSchema>;
    /**
     * Final Hp
     *
     * Character's HP at the end of combat.
     */
    final_hp: number;
};

/**
 * CharacterResponseSchema
 */
export type CharacterResponseSchema = {
    data: CharacterSchema;
};

/**
 * CharacterRestDataSchema
 */
export type CharacterRestDataSchema = {
    /**
     * Cooldown details
     */
    cooldown: CooldownSchema;
    /**
     * Hp Restored
     *
     * The amount of HP restored.
     */
    hp_restored: number;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * CharacterRestResponseSchema
 */
export type CharacterRestResponseSchema = {
    data: CharacterRestDataSchema;
};

/**
 * CharacterSchema
 */
export type CharacterSchema = {
    /**
     * Name
     *
     * Name of the character.
     */
    name: string;
    /**
     * Account
     *
     * Account name.
     */
    account: string;
    /**
     * Character skin code.
     */
    skin: CharacterSkin;
    /**
     * Level
     *
     * Combat level.
     */
    level: number;
    /**
     * Xp
     *
     * The current xp level of the combat level.
     */
    xp: number;
    /**
     * Max Xp
     *
     * XP required to level up the character.
     */
    max_xp: number;
    /**
     * Gold
     *
     * The numbers of gold on this character.
     */
    gold: number;
    /**
     * Speed
     *
     * *Not available, on the roadmap. Character movement speed.
     */
    speed: number;
    /**
     * Mining Level
     *
     * Mining level.
     */
    mining_level: number;
    /**
     * Mining Xp
     *
     * The current xp level of the Mining skill.
     */
    mining_xp: number;
    /**
     * Mining Max Xp
     *
     * Mining XP required to level up the skill.
     */
    mining_max_xp: number;
    /**
     * Woodcutting Level
     *
     * Woodcutting level.
     */
    woodcutting_level: number;
    /**
     * Woodcutting Xp
     *
     * The current xp level of the Woodcutting skill.
     */
    woodcutting_xp: number;
    /**
     * Woodcutting Max Xp
     *
     * Woodcutting XP required to level up the skill.
     */
    woodcutting_max_xp: number;
    /**
     * Fishing Level
     *
     * Fishing level.
     */
    fishing_level: number;
    /**
     * Fishing Xp
     *
     * The current xp level of the Fishing skill.
     */
    fishing_xp: number;
    /**
     * Fishing Max Xp
     *
     * Fishing XP required to level up the skill.
     */
    fishing_max_xp: number;
    /**
     * Weaponcrafting Level
     *
     * Weaponcrafting level.
     */
    weaponcrafting_level: number;
    /**
     * Weaponcrafting Xp
     *
     * The current xp level of the Weaponcrafting skill.
     */
    weaponcrafting_xp: number;
    /**
     * Weaponcrafting Max Xp
     *
     * Weaponcrafting XP required to level up the skill.
     */
    weaponcrafting_max_xp: number;
    /**
     * Gearcrafting Level
     *
     * Gearcrafting level.
     */
    gearcrafting_level: number;
    /**
     * Gearcrafting Xp
     *
     * The current xp level of the Gearcrafting skill.
     */
    gearcrafting_xp: number;
    /**
     * Gearcrafting Max Xp
     *
     * Gearcrafting XP required to level up the skill.
     */
    gearcrafting_max_xp: number;
    /**
     * Jewelrycrafting Level
     *
     * Jewelrycrafting level.
     */
    jewelrycrafting_level: number;
    /**
     * Jewelrycrafting Xp
     *
     * The current xp level of the Jewelrycrafting skill.
     */
    jewelrycrafting_xp: number;
    /**
     * Jewelrycrafting Max Xp
     *
     * Jewelrycrafting XP required to level up the skill.
     */
    jewelrycrafting_max_xp: number;
    /**
     * Cooking Level
     *
     * The current xp level of the Cooking skill.
     */
    cooking_level: number;
    /**
     * Cooking Xp
     *
     * Cooking XP.
     */
    cooking_xp: number;
    /**
     * Cooking Max Xp
     *
     * Cooking XP required to level up the skill.
     */
    cooking_max_xp: number;
    /**
     * Alchemy Level
     *
     * Alchemy level.
     */
    alchemy_level: number;
    /**
     * Alchemy Xp
     *
     * Alchemy XP.
     */
    alchemy_xp: number;
    /**
     * Alchemy Max Xp
     *
     * Alchemy XP required to level up the skill.
     */
    alchemy_max_xp: number;
    /**
     * Hp
     *
     * Character actual HP.
     */
    hp: number;
    /**
     * Max Hp
     *
     * Character max HP.
     */
    max_hp: number;
    /**
     * Haste
     *
     * *Increase speed attack (reduce fight cooldown)
     */
    haste: number;
    /**
     * Critical Strike
     *
     * % Critical strike. Critical strikes adds 50% extra damage to an attack (1.5x).
     */
    critical_strike: number;
    /**
     * Wisdom
     *
     * Wisdom increases the amount of XP gained from fights and skills (1% extra per 10 wisdom).
     */
    wisdom: number;
    /**
     * Prospecting
     *
     * Prospecting increases the chances of getting drops from fights and skills (1% extra per 10 PP).
     */
    prospecting: number;
    /**
     * Initiative
     *
     * Initiative determines turn order in combat. Higher initiative goes first.
     */
    initiative: number;
    /**
     * Threat
     *
     * Threat level affects monster targeting in multi-character combat.
     */
    threat: number;
    /**
     * Attack Fire
     *
     * Fire attack.
     */
    attack_fire: number;
    /**
     * Attack Earth
     *
     * Earth attack.
     */
    attack_earth: number;
    /**
     * Attack Water
     *
     * Water attack.
     */
    attack_water: number;
    /**
     * Attack Air
     *
     * Air attack.
     */
    attack_air: number;
    /**
     * Dmg
     *
     * % Damage. Damage increases your attack in all elements.
     */
    dmg: number;
    /**
     * Dmg Fire
     *
     * % Fire damage. Damage increases your fire attack.
     */
    dmg_fire: number;
    /**
     * Dmg Earth
     *
     * % Earth damage. Damage increases your earth attack.
     */
    dmg_earth: number;
    /**
     * Dmg Water
     *
     * % Water damage. Damage increases your water attack.
     */
    dmg_water: number;
    /**
     * Dmg Air
     *
     * % Air damage. Damage increases your air attack.
     */
    dmg_air: number;
    /**
     * Res Fire
     *
     * % Fire resistance. Reduces fire attack.
     */
    res_fire: number;
    /**
     * Res Earth
     *
     * % Earth resistance. Reduces earth attack.
     */
    res_earth: number;
    /**
     * Res Water
     *
     * % Water resistance. Reduces water attack.
     */
    res_water: number;
    /**
     * Res Air
     *
     * % Air resistance. Reduces air attack.
     */
    res_air: number;
    /**
     * Effects
     *
     * List of active effects on the character.
     */
    effects?: Array<StorageEffectSchema>;
    /**
     * X
     *
     * Character x coordinate.
     */
    x: number;
    /**
     * Y
     *
     * Character y coordinate.
     */
    y: number;
    /**
     * Character current layer.
     */
    layer: MapLayer;
    /**
     * Map Id
     *
     * Character current map ID.
     */
    map_id: number;
    /**
     * Cooldown
     *
     * Cooldown in seconds.
     */
    cooldown: number;
    /**
     * Cooldown Expiration
     *
     * Datetime Cooldown expiration.
     */
    cooldown_expiration?: string;
    /**
     * Weapon Slot
     *
     * Weapon slot.
     */
    weapon_slot: string;
    /**
     * Rune Slot
     *
     * Rune slot.
     */
    rune_slot: string;
    /**
     * Shield Slot
     *
     * Shield slot.
     */
    shield_slot: string;
    /**
     * Helmet Slot
     *
     * Helmet slot.
     */
    helmet_slot: string;
    /**
     * Body Armor Slot
     *
     * Body armor slot.
     */
    body_armor_slot: string;
    /**
     * Leg Armor Slot
     *
     * Leg armor slot.
     */
    leg_armor_slot: string;
    /**
     * Boots Slot
     *
     * Boots slot.
     */
    boots_slot: string;
    /**
     * Ring1 Slot
     *
     * Ring 1 slot.
     */
    ring1_slot: string;
    /**
     * Ring2 Slot
     *
     * Ring 2 slot.
     */
    ring2_slot: string;
    /**
     * Amulet Slot
     *
     * Amulet slot.
     */
    amulet_slot: string;
    /**
     * Artifact1 Slot
     *
     * Artifact 1 slot.
     */
    artifact1_slot: string;
    /**
     * Artifact2 Slot
     *
     * Artifact 2 slot.
     */
    artifact2_slot: string;
    /**
     * Artifact3 Slot
     *
     * Artifact 3 slot.
     */
    artifact3_slot: string;
    /**
     * Utility1 Slot
     *
     * Utility 1 slot.
     */
    utility1_slot: string;
    /**
     * Utility1 Slot Quantity
     *
     * Utility 1 quantity.
     */
    utility1_slot_quantity: number;
    /**
     * Utility2 Slot
     *
     * Utility 2 slot.
     */
    utility2_slot: string;
    /**
     * Utility2 Slot Quantity
     *
     * Utility 2 quantity.
     */
    utility2_slot_quantity: number;
    /**
     * Bag Slot
     *
     * Bag slot.
     */
    bag_slot: string;
    /**
     * Task
     *
     * Task in progress.
     */
    task: string;
    /**
     * Task Type
     *
     * Task type.
     */
    task_type: string;
    /**
     * Task Progress
     *
     * Task progression.
     */
    task_progress: number;
    /**
     * Task Total
     *
     * Task total objective.
     */
    task_total: number;
    /**
     * Inventory Max Items
     *
     * Inventory max items.
     */
    inventory_max_items: number;
    /**
     * Inventory
     *
     * List of inventory slots.
     */
    inventory?: Array<InventorySlot>;
};

/**
 * CharacterSkin
 */
export type CharacterSkin = 'men1' | 'men2' | 'men3' | 'women1' | 'women2' | 'women3' | 'corrupted1' | 'zombie1' | 'marauder1';

/**
 * CharacterTransitionDataSchema
 */
export type CharacterTransitionDataSchema = {
    /**
     * Cooldown details
     */
    cooldown: CooldownSchema;
    /**
     * Destination map details.
     */
    destination: MapSchema;
    /**
     * Transition details.
     */
    transition: TransitionSchema;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * CharacterTransitionResponseSchema
 */
export type CharacterTransitionResponseSchema = {
    data: CharacterTransitionDataSchema;
};

/**
 * CharactersListSchema
 */
export type CharactersListSchema = {
    /**
     * Data
     *
     * List of your characters.
     */
    data: Array<CharacterSchema>;
};

/**
 * CombatResultSchema
 */
export type CombatResultSchema = {
    /**
     * Result
     *
     * Combat result: 'win' or 'loss'.
     */
    result: string;
    /**
     * Turns
     *
     * Number of turns the combat lasted.
     */
    turns: number;
    /**
     * Logs
     *
     * Combat logs.
     */
    logs: Array<string>;
    /**
     * Character Results
     *
     * Character results from combat.
     */
    character_results: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * CombatSimulationDataSchema
 */
export type CombatSimulationDataSchema = {
    /**
     * Results
     *
     * Results from each combat iteration.
     */
    results: Array<CombatResultSchema>;
    /**
     * Wins
     *
     * Total number of victories.
     */
    wins: number;
    /**
     * Losses
     *
     * Total number of defeats.
     */
    losses: number;
    /**
     * Winrate
     *
     * Win rate percentage (0-100).
     */
    winrate: number;
};

/**
 * CombatSimulationRequestSchema
 */
export type CombatSimulationRequestSchema = {
    /**
     * Characters
     *
     * List of fake characters (1-3).
     */
    characters: Array<FakeCharacterSchema>;
    /**
     * Monster
     *
     * Monster code to fight against.
     */
    monster: string;
    /**
     * Iterations
     *
     * Number of combat iterations to simulate.
     */
    iterations: number;
};

/**
 * CombatSimulationResponseSchema
 */
export type CombatSimulationResponseSchema = {
    /**
     * Combat simulation results.
     */
    data: CombatSimulationDataSchema;
};

/**
 * ConditionOperator
 */
export type ConditionOperator = 'eq' | 'ne' | 'gt' | 'lt' | 'cost' | 'has_item' | 'achievement_unlocked';

/**
 * ConditionSchema
 */
export type ConditionSchema = {
    /**
     * Code
     *
     * Condition code.
     */
    code: string;
    /**
     * Condition operator.
     */
    operator: ConditionOperator;
    /**
     * Value
     *
     * Condition value.
     */
    value: number;
};

/**
 * CooldownSchema
 */
export type CooldownSchema = {
    /**
     * Total Seconds
     *
     * The total seconds of the cooldown.
     */
    total_seconds: number;
    /**
     * Remaining Seconds
     *
     * The remaining seconds of the cooldown.
     */
    remaining_seconds: number;
    /**
     * Started At
     *
     * The start of the cooldown.
     */
    started_at: string;
    /**
     * Expiration
     *
     * The expiration of the cooldown.
     */
    expiration: string;
    /**
     * The reason of the cooldown.
     */
    reason: ActionType;
};

/**
 * CraftSchema
 */
export type CraftSchema = {
    /**
     * Skill code
     *
     * Skill required to craft the item.
     */
    skill?: CraftSkill;
    /**
     * Level
     *
     * The skill level required to craft the item.
     */
    level?: number;
    /**
     * Items
     *
     * List of items required to craft the item.
     */
    items?: Array<SimpleItemSchema>;
    /**
     * Quantity
     *
     * Quantity of items crafted.
     */
    quantity?: number;
};

/**
 * CraftSkill
 */
export type CraftSkill = 'weaponcrafting' | 'gearcrafting' | 'jewelrycrafting' | 'cooking' | 'woodcutting' | 'mining' | 'alchemy';

/**
 * CraftingSchema
 */
export type CraftingSchema = {
    /**
     * Craft code
     *
     * Craft code.
     */
    code: string;
    /**
     * Quantity
     *
     * Quantity of items to craft.
     */
    quantity?: number;
};

/**
 * DataPage[AccountAchievementSchema]
 */
export type DataPageAccountAchievementSchema = {
    /**
     * Data
     */
    data: Array<AccountAchievementSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[AccountLeaderboardSchema]
 */
export type DataPageAccountLeaderboardSchema = {
    /**
     * Data
     */
    data: Array<AccountLeaderboardSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[AchievementSchema]
 */
export type DataPageAchievementSchema = {
    /**
     * Data
     */
    data: Array<AchievementSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[ActiveCharacterSchema]
 */
export type DataPageActiveCharacterSchema = {
    /**
     * Data
     */
    data: Array<ActiveCharacterSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[ActiveEventSchema]
 */
export type DataPageActiveEventSchema = {
    /**
     * Data
     */
    data: Array<ActiveEventSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[BadgeSchema]
 */
export type DataPageBadgeSchema = {
    /**
     * Data
     */
    data: Array<BadgeSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[CharacterLeaderboardSchema]
 */
export type DataPageCharacterLeaderboardSchema = {
    /**
     * Data
     */
    data: Array<CharacterLeaderboardSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[DropRateSchema]
 */
export type DataPageDropRateSchema = {
    /**
     * Data
     */
    data: Array<DropRateSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[EffectSchema]
 */
export type DataPageEffectSchema = {
    /**
     * Data
     */
    data: Array<EffectSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[EventSchema]
 */
export type DataPageEventSchema = {
    /**
     * Data
     */
    data: Array<EventSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[GEOrderSchema]
 */
export type DataPageGeOrderSchema = {
    /**
     * Data
     */
    data: Array<GeOrderSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[GeOrderHistorySchema]
 */
export type DataPageGeOrderHistorySchema = {
    /**
     * Data
     */
    data: Array<GeOrderHistorySchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[ItemSchema]
 */
export type DataPageItemSchema = {
    /**
     * Data
     */
    data: Array<ItemSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[LogSchema]
 */
export type DataPageLogSchema = {
    /**
     * Data
     */
    data: Array<LogSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[MapSchema]
 */
export type DataPageMapSchema = {
    /**
     * Data
     */
    data: Array<MapSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[MonsterSchema]
 */
export type DataPageMonsterSchema = {
    /**
     * Data
     */
    data: Array<MonsterSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[NPCItem]
 */
export type DataPageNpcItem = {
    /**
     * Data
     */
    data: Array<NpcItem>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[NPCSchema]
 */
export type DataPageNpcSchema = {
    /**
     * Data
     */
    data: Array<NpcSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[ResourceSchema]
 */
export type DataPageResourceSchema = {
    /**
     * Data
     */
    data: Array<ResourceSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[SimpleItemSchema]
 */
export type DataPageSimpleItemSchema = {
    /**
     * Data
     */
    data: Array<SimpleItemSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DataPage[TaskFullSchema]
 */
export type DataPageTaskFullSchema = {
    /**
     * Data
     */
    data: Array<TaskFullSchema>;
    /**
     * Total
     */
    total?: number;
    /**
     * Page
     */
    page?: number;
    /**
     * Size
     */
    size?: number;
    /**
     * Pages
     */
    pages?: number;
};

/**
 * DeleteCharacterSchema
 */
export type DeleteCharacterSchema = {
    /**
     * Name
     *
     * Character name.
     */
    name: string;
};

/**
 * DeleteItemResponseSchema
 */
export type DeleteItemResponseSchema = {
    data: DeleteItemSchema;
};

/**
 * DeleteItemSchema
 */
export type DeleteItemSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Item details.
     */
    item: SimpleItemSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * DepositWithdrawGoldSchema
 */
export type DepositWithdrawGoldSchema = {
    /**
     * Quantity
     *
     * Quantity of gold.
     */
    quantity: number;
};

/**
 * DestinationSchema
 */
export type DestinationSchema = {
    /**
     * X
     *
     * The x coordinate of the destination.
     */
    x?: number;
    /**
     * Y
     *
     * The y coordinate of the destination.
     */
    y?: number;
    /**
     * Map Id
     *
     * The map ID of the destination.
     */
    map_id?: number;
};

/**
 * DropRateSchema
 */
export type DropRateSchema = {
    /**
     * Item code
     *
     * Item code.
     */
    code: string;
    /**
     * Rate
     *
     * Chance rate. (1/rate)
     */
    rate: number;
    /**
     * Min Quantity
     *
     * Minimum quantity.
     */
    min_quantity: number;
    /**
     * Max Quantity
     *
     * Maximum quantity.
     */
    max_quantity: number;
};

/**
 * DropSchema
 */
export type DropSchema = {
    /**
     * Code
     *
     * The code of the item.
     */
    code: string;
    /**
     * Quantity
     *
     * The quantity of the item.
     */
    quantity: number;
};

/**
 * EffectResponseSchema
 */
export type EffectResponseSchema = {
    data: EffectSchema;
};

/**
 * EffectSchema
 */
export type EffectSchema = {
    /**
     * Name
     *
     * Name of the effect.
     */
    name: string;
    /**
     * Code
     *
     * The code of the effect. This is the effect's unique identifier (ID).
     */
    code: string;
    /**
     * Description
     *
     * Description of the effect. This is a brief description of the effect.
     */
    description: string;
    /**
     * Type of the effect.
     */
    type: EffectType;
    /**
     * Subtype of the effect.
     */
    subtype: EffectSubtype;
};

/**
 * EffectSubtype
 */
export type EffectSubtype = 'stat' | 'other' | 'heal' | 'buff' | 'debuff' | 'special' | 'gathering' | 'teleport' | 'gold';

/**
 * EffectType
 */
export type EffectType = 'equipment' | 'consumable' | 'combat';

/**
 * EquipRequestSchema
 */
export type EquipRequestSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Item slot.
     */
    slot: ItemSlot;
    /**
     * Item details.
     */
    item: ItemSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * EquipSchema
 */
export type EquipSchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Item slot.
     */
    slot: ItemSlot;
    /**
     * Quantity
     *
     * Item quantity. Applicable to utilities only.
     */
    quantity?: number;
};

/**
 * EquipmentResponseSchema
 */
export type EquipmentResponseSchema = {
    data: EquipRequestSchema;
};

/**
 * EventContentSchema
 */
export type EventContentSchema = {
    /**
     * Type of the event.
     */
    type: MapContentType;
    /**
     * Code
     *
     * Code content.
     */
    code: string;
};

/**
 * EventMapSchema
 */
export type EventMapSchema = {
    /**
     * Map Id
     *
     * ID of the map.
     */
    map_id: number;
    /**
     * X
     *
     * Position X of the map.
     */
    x: number;
    /**
     * Y
     *
     * Position Y of the map.
     */
    y: number;
    /**
     * Layer
     *
     * Layer of the map.
     */
    layer: string;
    /**
     * Skin
     *
     * Map skin of the map
     */
    skin: string;
};

/**
 * EventSchema
 */
export type EventSchema = {
    /**
     * Name
     *
     * Name of the event.
     */
    name: string;
    /**
     * Code
     *
     * Code of the event.
     */
    code: string;
    /**
     * Content of the event.
     */
    content: EventContentSchema;
    /**
     * Maps
     *
     * Map list of the event.
     */
    maps: Array<EventMapSchema>;
    /**
     * Duration
     *
     * Duration in minutes.
     */
    duration: number;
    /**
     * Rate
     *
     * Rate spawn of the event. (1/rate every minute)
     */
    rate: number;
};

/**
 * FakeCharacterSchema
 */
export type FakeCharacterSchema = {
    /**
     * Level
     *
     * Character level.
     */
    level: number;
    /**
     * Weapon Slot
     *
     * Weapon slot item code.
     */
    weapon_slot?: string;
    /**
     * Rune Slot
     *
     * Rune slot item code.
     */
    rune_slot?: string;
    /**
     * Shield Slot
     *
     * Shield slot item code.
     */
    shield_slot?: string;
    /**
     * Helmet Slot
     *
     * Helmet slot item code.
     */
    helmet_slot?: string;
    /**
     * Body Armor Slot
     *
     * Body armor slot item code.
     */
    body_armor_slot?: string;
    /**
     * Leg Armor Slot
     *
     * Leg armor slot item code.
     */
    leg_armor_slot?: string;
    /**
     * Boots Slot
     *
     * Boots slot item code.
     */
    boots_slot?: string;
    /**
     * Ring1 Slot
     *
     * Ring 1 slot item code.
     */
    ring1_slot?: string;
    /**
     * Ring2 Slot
     *
     * Ring 2 slot item code.
     */
    ring2_slot?: string;
    /**
     * Amulet Slot
     *
     * Amulet slot item code.
     */
    amulet_slot?: string;
    /**
     * Artifact1 Slot
     *
     * Artifact 1 slot item code.
     */
    artifact1_slot?: string;
    /**
     * Artifact2 Slot
     *
     * Artifact 2 slot item code.
     */
    artifact2_slot?: string;
    /**
     * Artifact3 Slot
     *
     * Artifact 3 slot item code.
     */
    artifact3_slot?: string;
    /**
     * Utility1 Slot
     *
     * Utility 1 slot item code.
     */
    utility1_slot?: string;
    /**
     * Utility1 Slot Quantity
     *
     * Utility 1 quantity.
     */
    utility1_slot_quantity?: number;
    /**
     * Utility2 Slot
     *
     * Utility 2 slot item code.
     */
    utility2_slot?: string;
    /**
     * Utility2 Slot Quantity
     *
     * Utility 2 quantity.
     */
    utility2_slot_quantity?: number;
};

/**
 * FightRequestSchema
 */
export type FightRequestSchema = {
    /**
     * Participants
     *
     * Optional list of additional character names to include in the fight (max 2 additional characters).
     */
    participants?: Array<string>;
};

/**
 * FightResult
 */
export type FightResult = 'win' | 'loss';

/**
 * GEBuyOrderSchema
 */
export type GeBuyOrderSchema = {
    /**
     * Id
     *
     * Order id.
     */
    id: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
};

/**
 * GECancelOrderSchema
 */
export type GeCancelOrderSchema = {
    /**
     * Id
     *
     * Order id.
     */
    id: string;
};

/**
 * GECreateOrderTransactionResponseSchema
 */
export type GeCreateOrderTransactionResponseSchema = {
    data: GeOrderTransactionSchema;
};

/**
 * GEOrderCreatedSchema
 */
export type GeOrderCreatedSchema = {
    /**
     * Id
     *
     * Order id.
     */
    id: string;
    /**
     * Created At
     *
     * Order created at.
     */
    created_at: string;
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Price
     *
     * Item price per unit.
     */
    price: number;
    /**
     * Total Price
     *
     * Total price.
     */
    total_price: number;
    /**
     * Tax
     *
     * Listing tax (3%, minimum 1)
     */
    tax: number;
};

/**
 * GEOrderCreationrSchema
 */
export type GeOrderCreationrSchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Price
     *
     * Item price per unit.
     */
    price: number;
};

/**
 * GEOrderResponseSchema
 */
export type GeOrderResponseSchema = {
    data: GeOrderSchema;
};

/**
 * GEOrderSchema
 */
export type GeOrderSchema = {
    /**
     * Id
     *
     * Order id.
     */
    id: string;
    /**
     * Seller
     *
     * Seller account name.
     */
    seller: string;
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Price
     *
     * Item price per unit.
     */
    price: number;
    /**
     * Created At
     *
     * Order created at.
     */
    created_at: string;
};

/**
 * GEOrderTransactionSchema
 */
export type GeOrderTransactionSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Order details.
     */
    order: GeOrderCreatedSchema;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * GETransactionListSchema
 */
export type GeTransactionListSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Transaction details.
     */
    order: GeTransactionSchema;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * GETransactionResponseSchema
 */
export type GeTransactionResponseSchema = {
    data: GeTransactionListSchema;
};

/**
 * GETransactionSchema
 */
export type GeTransactionSchema = {
    /**
     * Id
     *
     * Order id.
     */
    id: string;
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Price
     *
     * Item price.
     */
    price: number;
    /**
     * Total Price
     *
     * Total price of the transaction.
     */
    total_price: number;
};

/**
 * GatheringSkill
 */
export type GatheringSkill = 'mining' | 'woodcutting' | 'fishing' | 'alchemy';

/**
 * GeOrderHistorySchema
 */
export type GeOrderHistorySchema = {
    /**
     * Order Id
     *
     * Order id.
     */
    order_id: string;
    /**
     * Seller
     *
     * Seller account name.
     */
    seller: string;
    /**
     * Buyer
     *
     * Buyer account name.
     */
    buyer: string;
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Price
     *
     * Item price per unit.
     */
    price: number;
    /**
     * Sold At
     *
     * Sale datetime.
     */
    sold_at: string;
};

/**
 * GiveGoldDataSchema
 */
export type GiveGoldDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Quantity
     *
     * Quantity of gold given.
     */
    quantity: number;
    /**
     * Character details of the receiving character.
     */
    receiver_character: CharacterSchema;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * GiveGoldResponseSchema
 */
export type GiveGoldResponseSchema = {
    data: GiveGoldDataSchema;
};

/**
 * GiveGoldSchema
 */
export type GiveGoldSchema = {
    /**
     * Quantity
     *
     * Gold quantity.
     */
    quantity: number;
    /**
     * Character
     *
     * Character name. The name of the character who will receive the gold.
     */
    character: string;
};

/**
 * GiveItemDataSchema
 */
export type GiveItemDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Items
     *
     * Items given.
     */
    items: Array<SimpleItemSchema>;
    /**
     * Character details of the receiving character.
     */
    receiver_character: CharacterSchema;
    /**
     * Character details of the sending character.
     */
    character: CharacterSchema;
};

/**
 * GiveItemResponseSchema
 */
export type GiveItemResponseSchema = {
    data: GiveItemDataSchema;
};

/**
 * GiveItemsSchema
 */
export type GiveItemsSchema = {
    /**
     * Items
     *
     * List of items to give
     */
    items: Array<SimpleItemSchema>;
    /**
     * Character
     *
     * Character name. The name of the character who will receive the items.
     */
    character: string;
};

/**
 * GoldSchema
 */
export type GoldSchema = {
    /**
     * Quantity
     *
     * Quantity of gold.
     */
    quantity: number;
};

/**
 * HTTPValidationError
 */
export type HttpValidationError = {
    /**
     * Detail
     */
    detail?: Array<ValidationError>;
};

/**
 * InteractionSchema
 */
export type InteractionSchema = {
    /**
     * Content of the map.
     */
    content?: MapContentSchema;
    /**
     * Transition to another map.
     */
    transition?: TransitionSchema;
};

/**
 * InventorySlot
 */
export type InventorySlot = {
    /**
     * Slot
     *
     * Inventory slot identifier.
     */
    slot: number;
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Quantity in the slot.
     */
    quantity: number;
};

/**
 * ItemResponseSchema
 */
export type ItemResponseSchema = {
    data: ItemSchema;
};

/**
 * ItemSchema
 */
export type ItemSchema = {
    /**
     * Name
     *
     * Item name.
     */
    name: string;
    /**
     * Code
     *
     * Item code. This is the item's unique identifier (ID).
     */
    code: string;
    /**
     * Level
     *
     * Item level.
     */
    level: number;
    /**
     * Type
     *
     * Item type.
     */
    type: string;
    /**
     * Subtype
     *
     * Item subtype.
     */
    subtype: string;
    /**
     * Description
     *
     * Item description.
     */
    description: string;
    /**
     * Conditions
     *
     * Item conditions. If applicable. Conditions for using or equipping the item.
     */
    conditions?: Array<ConditionSchema>;
    /**
     * Effects
     *
     * List of object effects. For equipment, it will include item stats.
     */
    effects?: Array<SimpleEffectSchema>;
    /**
     * Craft information. If applicable.
     */
    craft?: CraftSchema;
    /**
     * Tradeable
     *
     * Item tradeable status. A non-tradeable item cannot be exchanged or sold.
     */
    tradeable: boolean;
};

/**
 * ItemSlot
 */
export type ItemSlot = 'weapon' | 'shield' | 'helmet' | 'body_armor' | 'leg_armor' | 'boots' | 'ring1' | 'ring2' | 'amulet' | 'artifact1' | 'artifact2' | 'artifact3' | 'utility1' | 'utility2' | 'bag' | 'rune';

/**
 * ItemType
 */
export type ItemType = 'utility' | 'body_armor' | 'weapon' | 'resource' | 'leg_armor' | 'helmet' | 'boots' | 'shield' | 'amulet' | 'ring' | 'artifact' | 'currency' | 'consumable' | 'rune' | 'bag';

/**
 * LogSchema
 */
export type LogSchema = {
    /**
     * Character
     *
     * Character name.
     */
    character: string;
    /**
     * Account
     *
     * Account character.
     */
    account: string;
    /**
     * Type of action.
     */
    type: LogType;
    /**
     * Description
     *
     * Description of action.
     */
    description: string;
    /**
     * Content
     *
     * Content of action.
     */
    content: unknown;
    /**
     * Cooldown
     *
     * Cooldown in seconds.
     */
    cooldown: number;
    /**
     * Cooldown Expiration
     *
     * Datetime of cooldown expiration.
     */
    cooldown_expiration?: string;
    /**
     * Created At
     *
     * Datetime of creation.
     */
    created_at: string;
};

/**
 * LogType
 */
export type LogType = 'spawn' | 'movement' | 'fight' | 'multi_fight' | 'crafting' | 'gathering' | 'buy_ge' | 'sell_ge' | 'buy_npc' | 'sell_npc' | 'cancel_ge' | 'delete_item' | 'deposit_item' | 'withdraw_item' | 'deposit_gold' | 'withdraw_gold' | 'equip' | 'unequip' | 'new_task' | 'task_exchange' | 'task_cancelled' | 'task_completed' | 'task_trade' | 'recycling' | 'rest' | 'use' | 'buy_bank_expansion' | 'achievement' | 'give_item' | 'give_gold' | 'receive_item' | 'receive_gold' | 'change_skin' | 'rename' | 'transition';

/**
 * MapAccessType
 */
export type MapAccessType = 'standard' | 'teleportation' | 'conditional' | 'blocked';

/**
 * MapContentSchema
 */
export type MapContentSchema = {
    /**
     * Type of the content.
     */
    type: MapContentType;
    /**
     * Code
     *
     * Code of the content.
     */
    code: string;
};

/**
 * MapContentType
 */
export type MapContentType = 'monster' | 'resource' | 'workshop' | 'bank' | 'grand_exchange' | 'tasks_master' | 'npc';

/**
 * MapLayer
 */
export type MapLayer = 'interior' | 'overworld' | 'underground';

/**
 * MapResponseSchema
 */
export type MapResponseSchema = {
    data: MapSchema;
};

/**
 * MapSchema
 */
export type MapSchema = {
    /**
     * Map Id
     *
     * ID of the map.
     */
    map_id: number;
    /**
     * Name
     *
     * Name of the map.
     */
    name: string;
    /**
     * Skin
     *
     * Skin of the map.
     */
    skin: string;
    /**
     * X
     *
     * Position X of the map.
     */
    x: number;
    /**
     * Y
     *
     * Position Y of the map.
     */
    y: number;
    /**
     * Layer of the map.
     */
    layer: MapLayer;
    /**
     * Access information for the map
     */
    access: AccessSchema;
    /**
     * Interactions available on this map.
     */
    interactions: InteractionSchema;
};

/**
 * MonsterResponseSchema
 */
export type MonsterResponseSchema = {
    data: MonsterSchema;
};

/**
 * MonsterSchema
 */
export type MonsterSchema = {
    /**
     * Name
     *
     * Name of the monster.
     */
    name: string;
    /**
     * Code
     *
     * The code of the monster. This is the monster's unique identifier (ID).
     */
    code: string;
    /**
     * Level
     *
     * Monster level.
     */
    level: number;
    /**
     * Monster type.
     */
    type: MonsterType;
    /**
     * Hp
     *
     * Monster hit points.
     */
    hp: number;
    /**
     * Attack Fire
     *
     * Monster fire attack.
     */
    attack_fire: number;
    /**
     * Attack Earth
     *
     * Monster earth attack.
     */
    attack_earth: number;
    /**
     * Attack Water
     *
     * Monster water attack.
     */
    attack_water: number;
    /**
     * Attack Air
     *
     * Monster air attack.
     */
    attack_air: number;
    /**
     * Res Fire
     *
     * Monster % fire resistance.
     */
    res_fire: number;
    /**
     * Res Earth
     *
     * Monster % earth resistance.
     */
    res_earth: number;
    /**
     * Res Water
     *
     * Monster % water resistance.
     */
    res_water: number;
    /**
     * Res Air
     *
     * Monster % air resistance.
     */
    res_air: number;
    /**
     * Critical Strike
     *
     * Monster % critical strike.
     */
    critical_strike: number;
    /**
     * Initiative
     *
     * Monster initiative for turn order.
     */
    initiative: number;
    /**
     * Effects
     *
     * List of effects.
     */
    effects?: Array<SimpleEffectSchema>;
    /**
     * Min Gold
     *
     * Monster minimum gold drop.
     */
    min_gold: number;
    /**
     * Max Gold
     *
     * Monster maximum gold drop.
     */
    max_gold: number;
    /**
     * Drops
     *
     * Monster drops. This is a list of items that the monster drops after killing the monster.
     */
    drops: Array<DropRateSchema>;
};

/**
 * MonsterType
 */
export type MonsterType = 'normal' | 'elite' | 'boss';

/**
 * MyAccountDetails
 */
export type MyAccountDetails = {
    /**
     * Username
     *
     * Username.
     */
    username: string;
    /**
     * Email
     *
     * Email.
     */
    email: string;
    /**
     * Member
     *
     * Member status.
     */
    member: boolean;
    /**
     * Member Expiration
     *
     * Member expiration date.
     */
    member_expiration?: string;
    /**
     * Account status.
     */
    status: AccountStatus;
    /**
     * Badges
     *
     * Account badges.
     */
    badges?: Array<string>;
    /**
     * Skins
     *
     * Skins owned.
     */
    skins: Array<string>;
    /**
     * Gems
     *
     * Gems.
     */
    gems: number;
    /**
     * Event Token
     *
     * Event tokens for spawning events.
     */
    event_token: number;
    /**
     * Achievements Points
     *
     * Achievement points.
     */
    achievements_points: number;
    /**
     * Banned
     *
     * Banned.
     */
    banned: boolean;
    /**
     * Ban Reason
     *
     * Ban reason.
     */
    ban_reason?: string;
};

/**
 * MyAccountDetailsSchema
 */
export type MyAccountDetailsSchema = {
    data: MyAccountDetails;
};

/**
 * MyCharactersListSchema
 */
export type MyCharactersListSchema = {
    /**
     * Data
     *
     * List of your characters.
     */
    data: Array<CharacterSchema>;
};

/**
 * NPCItem
 */
export type NpcItem = {
    /**
     * Code
     *
     * The code of the NPC. This is the NPC's unique identifier (ID).
     */
    code: string;
    /**
     * Npc
     *
     * Code of the NPC that sells/buys the item.
     */
    npc: string;
    /**
     * Currency
     *
     * Currency used to buy/sell the item. If it's not gold, it's the item code.
     */
    currency: string;
    /**
     * Buy Price
     *
     * Price to buy the item.
     */
    buy_price?: number;
    /**
     * Sell Price
     *
     * Price to sell the item.
     */
    sell_price?: number;
};

/**
 * NPCResponseSchema
 */
export type NpcResponseSchema = {
    data: NpcSchema;
};

/**
 * NPCSchema
 */
export type NpcSchema = {
    /**
     * Name
     *
     * Name of the NPC.
     */
    name: string;
    /**
     * Code
     *
     * The code of the NPC. This is the NPC's unique identifier (ID).
     */
    code: string;
    /**
     * Description
     *
     * Description of the NPC.
     */
    description: string;
    /**
     * Type of the NPC.
     */
    type: NpcType;
};

/**
 * NPCType
 */
export type NpcType = 'merchant' | 'trader';

/**
 * NpcItemTransactionSchema
 */
export type NpcItemTransactionSchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
    /**
     * Currency
     *
     * Currency used for the transaction.
     */
    currency: string;
    /**
     * Price
     *
     * Item price.
     */
    price: number;
    /**
     * Total Price
     *
     * Total price of the transaction.
     */
    total_price: number;
};

/**
 * NpcMerchantBuySchema
 */
export type NpcMerchantBuySchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
};

/**
 * NpcMerchantTransactionResponseSchema
 */
export type NpcMerchantTransactionResponseSchema = {
    data: NpcMerchantTransactionSchema;
};

/**
 * NpcMerchantTransactionSchema
 */
export type NpcMerchantTransactionSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Transaction details.
     */
    transaction: NpcItemTransactionSchema;
    /**
     * Character details.
     */
    character: CharacterSchema;
};

/**
 * PasswordResetConfirmSchema
 */
export type PasswordResetConfirmSchema = {
    /**
     * Token
     *
     * Password reset token.
     */
    token: string;
    /**
     * New Password
     *
     * Your new password.
     */
    new_password: string;
};

/**
 * PasswordResetRequestSchema
 */
export type PasswordResetRequestSchema = {
    /**
     * Email
     *
     * Your email address.
     */
    email: string;
};

/**
 * PasswordResetResponseSchema
 */
export type PasswordResetResponseSchema = {
    /**
     * Message
     *
     * Success message.
     */
    message: string;
};

/**
 * RateLimitSchema
 */
export type RateLimitSchema = {
    /**
     * Type
     *
     * Type of rate limit.
     */
    type: string;
    /**
     * Value
     *
     * Value of the rate limit.
     */
    value: string;
};

/**
 * RecyclingDataSchema
 */
export type RecyclingDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Craft details.
     */
    details: RecyclingItemsSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * RecyclingItemsSchema
 */
export type RecyclingItemsSchema = {
    /**
     * Items
     *
     * Objects received.
     */
    items: Array<DropSchema>;
};

/**
 * RecyclingResponseSchema
 */
export type RecyclingResponseSchema = {
    data: RecyclingDataSchema;
};

/**
 * RecyclingSchema
 */
export type RecyclingSchema = {
    /**
     * Item code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Quantity of items to recycle.
     */
    quantity?: number;
};

/**
 * ResourceResponseSchema
 */
export type ResourceResponseSchema = {
    data: ResourceSchema;
};

/**
 * ResourceSchema
 */
export type ResourceSchema = {
    /**
     * Name
     *
     * The name of the resource
     */
    name: string;
    /**
     * Code
     *
     * The code of the resource. This is the resource's unique identifier (ID).
     */
    code: string;
    /**
     * Skill code
     *
     * The skill required to gather this resource.
     */
    skill: GatheringSkill;
    /**
     * Level
     *
     * The skill level required to gather this resource.
     */
    level: number;
    /**
     * Drops
     *
     * The drops of this resource.
     */
    drops: Array<DropRateSchema>;
};

/**
 * ResponseSchema
 */
export type ResponseSchema = {
    /**
     * Message
     */
    message: string;
};

/**
 * RewardDataResponseSchema
 */
export type RewardDataResponseSchema = {
    data: RewardDataSchema;
};

/**
 * RewardDataSchema
 */
export type RewardDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Reward details.
     */
    rewards: RewardsSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * RewardResponseSchema
 */
export type RewardResponseSchema = {
    data: DropRateSchema;
};

/**
 * RewardsSchema
 */
export type RewardsSchema = {
    /**
     * Items
     *
     * Items rewards.
     */
    items: Array<SimpleItemSchema>;
    /**
     * Gold
     *
     * Gold rewards.
     */
    gold: number;
};

/**
 * SeasonBadgeSchema
 */
export type SeasonBadgeSchema = {
    /**
     * Code
     *
     * Badge code.
     */
    code: string;
    /**
     * Description
     *
     * Badge description.
     */
    description: string;
    /**
     * Required Points
     *
     * Required achievement points to earn the badge.
     */
    required_points: number;
};

/**
 * SeasonSchema
 */
export type SeasonSchema = {
    /**
     * Name
     *
     * Season name.
     */
    name?: string;
    /**
     * Number
     *
     * Season number.
     */
    number?: number;
    /**
     * Start Date
     *
     * Season start date.
     */
    start_date?: string;
    /**
     * Badges
     *
     * Season badges with required achievement points.
     */
    badges: Array<SeasonBadgeSchema>;
    /**
     * Skins
     *
     * Season skins with required achievement points.
     */
    skins: Array<SeasonSkinSchema>;
};

/**
 * SeasonSkinSchema
 */
export type SeasonSkinSchema = {
    /**
     * Code
     *
     * Skin code.
     */
    code: string;
    /**
     * Description
     *
     * Skin description.
     */
    description: string;
    /**
     * Required Points
     *
     * Required achievement points to earn the skin.
     */
    required_points: number;
};

/**
 * SimpleEffectSchema
 */
export type SimpleEffectSchema = {
    /**
     * Code
     *
     * Effect code.
     */
    code: string;
    /**
     * Value
     *
     * Effect value.
     */
    value: number;
    /**
     * Description
     *
     * Description of the effect.
     */
    description: string;
};

/**
 * SimpleItemSchema
 */
export type SimpleItemSchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
};

/**
 * Skill
 */
export type Skill = 'weaponcrafting' | 'gearcrafting' | 'jewelrycrafting' | 'cooking' | 'woodcutting' | 'mining' | 'alchemy' | 'fishing';

/**
 * SkillDataSchema
 */
export type SkillDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Craft details.
     */
    details: SkillInfoSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * SkillInfoSchema
 */
export type SkillInfoSchema = {
    /**
     * Xp
     *
     * The amount of xp gained.
     */
    xp: number;
    /**
     * Items
     *
     * Objects received.
     */
    items: Array<DropSchema>;
};

/**
 * SkillResponseSchema
 */
export type SkillResponseSchema = {
    data: SkillDataSchema;
};

/**
 * SpawnEventRequest
 *
 * Model for the request to spawn a specific event
 */
export type SpawnEventRequest = {
    /**
     * Code
     *
     * Code of the event to spawn
     */
    code: string;
};

/**
 * StatusResponseSchema
 */
export type StatusResponseSchema = {
    data: StatusSchema;
};

/**
 * StatusSchema
 */
export type StatusSchema = {
    /**
     * Version
     *
     * Game version.
     */
    version: string;
    /**
     * Server Time
     *
     * Server time.
     */
    server_time: string;
    /**
     * Max Level
     *
     * Maximum level.
     */
    max_level: number;
    /**
     * Max Skill Level
     *
     * Maximum skill level.
     */
    max_skill_level: number;
    /**
     * Characters Online
     *
     * Characters online.
     */
    characters_online: number;
    /**
     * Current season details.
     */
    season?: SeasonSchema;
    /**
     * Rate Limits
     *
     * Rate limits.
     */
    rate_limits: Array<RateLimitSchema>;
};

/**
 * StorageEffectSchema
 */
export type StorageEffectSchema = {
    /**
     * Code
     *
     * Effect code.
     */
    code: string;
    /**
     * Value
     *
     * Effect value.
     */
    value: number;
};

/**
 * TaskCancelledResponseSchema
 */
export type TaskCancelledResponseSchema = {
    data: TaskCancelledSchema;
};

/**
 * TaskCancelledSchema
 */
export type TaskCancelledSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * TaskDataSchema
 */
export type TaskDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Task details.
     */
    task: TaskSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * TaskFullResponseSchema
 */
export type TaskFullResponseSchema = {
    data: TaskFullSchema;
};

/**
 * TaskFullSchema
 */
export type TaskFullSchema = {
    /**
     * Code
     *
     * Task objective.
     */
    code: string;
    /**
     * Level
     *
     * Task level.
     */
    level: number;
    /**
     * Type
     *
     * The type of task.
     */
    type: TaskType;
    /**
     * Min Quantity
     *
     * Minimum amount of task.
     */
    min_quantity: number;
    /**
     * Max Quantity
     *
     * Maximum amount of task.
     */
    max_quantity: number;
    /**
     * Skill
     *
     * Skill required to complete the task.
     */
    skill?: string;
    /**
     * Rewards.
     */
    rewards: RewardsSchema;
};

/**
 * TaskResponseSchema
 */
export type TaskResponseSchema = {
    data: TaskDataSchema;
};

/**
 * TaskSchema
 */
export type TaskSchema = {
    /**
     * Code
     *
     * Task objective.
     */
    code: string;
    /**
     * Type
     *
     * The type of task.
     */
    type: TaskType;
    /**
     * Total
     *
     * The total required to complete the task.
     */
    total: number;
    /**
     * Rewards for completing the task.
     */
    rewards: RewardsSchema;
};

/**
 * TaskTradeDataSchema
 */
export type TaskTradeDataSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Reward details.
     */
    trade: TaskTradeSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * TaskTradeResponseSchema
 */
export type TaskTradeResponseSchema = {
    data: TaskTradeDataSchema;
};

/**
 * TaskTradeSchema
 */
export type TaskTradeSchema = {
    /**
     * Code
     *
     * Item code.
     */
    code: string;
    /**
     * Quantity
     *
     * Item quantity.
     */
    quantity: number;
};

/**
 * TaskType
 */
export type TaskType = 'monsters' | 'items';

/**
 * TokenResponseSchema
 */
export type TokenResponseSchema = {
    /**
     * Token
     */
    token: string;
};

/**
 * TransitionSchema
 */
export type TransitionSchema = {
    /**
     * Map Id
     *
     * ID of the destination map.
     */
    map_id: number;
    /**
     * X
     *
     * Position X of the destination.
     */
    x: number;
    /**
     * Y
     *
     * Position Y of the destination.
     */
    y: number;
    /**
     * Layer of the destination.
     */
    layer: MapLayer;
    /**
     * Conditions
     *
     * Conditions for the transition.
     */
    conditions?: Array<ConditionSchema>;
};

/**
 * UnequipSchema
 */
export type UnequipSchema = {
    /**
     * Item slot.
     */
    slot: ItemSlot;
    /**
     * Quantity
     *
     * Item quantity. Applicable to utilities only.
     */
    quantity?: number;
};

/**
 * UseItemResponseSchema
 */
export type UseItemResponseSchema = {
    data: UseItemSchema;
};

/**
 * UseItemSchema
 */
export type UseItemSchema = {
    /**
     * Cooldown details.
     */
    cooldown: CooldownSchema;
    /**
     * Item details.
     */
    item: ItemSchema;
    /**
     * Player details.
     */
    character: CharacterSchema;
};

/**
 * ValidationError
 */
export type ValidationError = {
    /**
     * Location
     */
    loc: Array<string | number>;
    /**
     * Message
     */
    msg: string;
    /**
     * Error Type
     */
    type: string;
};

export type ErrorSchema = {
    /**
     * Error code
     */
    code: number;
    /**
     * Error message
     */
    message: string;
    /**
     * Additional error data (used primarily for validation errors)
     */
    data?: {
        [key: string]: unknown;
    };
};

export type ErrorResponseSchema = {
    error: ErrorSchema;
};

export type GetServerDetailsGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/';
};

export type GetServerDetailsGetResponses = {
    /**
     * Successfully fetched status.
     */
    200: StatusResponseSchema;
};

export type GetServerDetailsGetResponse = GetServerDetailsGetResponses[keyof GetServerDetailsGetResponses];

export type GetBankDetailsMyBankGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/my/bank';
};

export type GetBankDetailsMyBankGetResponses = {
    /**
     * Successfully fetched bank details.
     */
    200: BankResponseSchema;
};

export type GetBankDetailsMyBankGetResponse = GetBankDetailsMyBankGetResponses[keyof GetBankDetailsMyBankGetResponses];

export type GetBankItemsMyBankItemsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item code
         *
         * Item to search in your bank.
         */
        item_code?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/my/bank/items';
};

export type GetBankItemsMyBankItemsGetResponses = {
    /**
     * Successfully fetched data.
     */
    200: DataPageSimpleItemSchema;
};

export type GetBankItemsMyBankItemsGetResponse = GetBankItemsMyBankItemsGetResponses[keyof GetBankItemsMyBankItemsGetResponses];

export type GetGeSellOrdersMyGrandexchangeOrdersGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item code
         *
         * The code of the item.
         */
        code?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/my/grandexchange/orders';
};

export type GetGeSellOrdersMyGrandexchangeOrdersGetResponses = {
    /**
     * Successfully fetched data.
     */
    200: DataPageGeOrderSchema;
};

export type GetGeSellOrdersMyGrandexchangeOrdersGetResponse = GetGeSellOrdersMyGrandexchangeOrdersGetResponses[keyof GetGeSellOrdersMyGrandexchangeOrdersGetResponses];

export type GetGeSellHistoryMyGrandexchangeHistoryGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Order ID
         *
         * Order ID to search in your history.
         */
        id?: string;
        /**
         * Item code
         *
         * Item to search in your history.
         */
        code?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/my/grandexchange/history';
};

export type GetGeSellHistoryMyGrandexchangeHistoryGetResponses = {
    /**
     * Successfully fetched data.
     */
    200: DataPageGeOrderHistorySchema;
};

export type GetGeSellHistoryMyGrandexchangeHistoryGetResponse = GetGeSellHistoryMyGrandexchangeHistoryGetResponses[keyof GetGeSellHistoryMyGrandexchangeHistoryGetResponses];

export type GetAccountDetailsMyDetailsGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/my/details';
};

export type GetAccountDetailsMyDetailsGetResponses = {
    /**
     * Successfully fetched data.
     */
    200: MyAccountDetailsSchema;
};

export type GetAccountDetailsMyDetailsGetResponse = GetAccountDetailsMyDetailsGetResponses[keyof GetAccountDetailsMyDetailsGetResponses];

export type ChangePasswordMyChangePasswordPostData = {
    body: ChangePassword;
    path?: never;
    query?: never;
    url: '/my/change_password';
};

export type ChangePasswordMyChangePasswordPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Please use a different password.
     */
    458: ErrorResponseSchema;
    /**
     * The current password you entered is invalid.
     */
    459: ErrorResponseSchema;
};

export type ChangePasswordMyChangePasswordPostError = ChangePasswordMyChangePasswordPostErrors[keyof ChangePasswordMyChangePasswordPostErrors];

export type ChangePasswordMyChangePasswordPostResponses = {
    /**
     * Password changed successfully.
     */
    200: ResponseSchema;
};

export type ChangePasswordMyChangePasswordPostResponse = ChangePasswordMyChangePasswordPostResponses[keyof ChangePasswordMyChangePasswordPostResponses];

export type ActionMoveMyNameActionMovePostData = {
    body: DestinationSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/move';
};

export type ActionMoveMyNameActionMovePostErrors = {
    /**
     * Map not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character is already at the destination.
     */
    490: ErrorResponseSchema;
    /**
     * Conditions not met.
     */
    496: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * No path available to the destination map.
     */
    595: ErrorResponseSchema;
    /**
     * The map is blocked and cannot be accessed.
     */
    596: ErrorResponseSchema;
};

export type ActionMoveMyNameActionMovePostError = ActionMoveMyNameActionMovePostErrors[keyof ActionMoveMyNameActionMovePostErrors];

export type ActionMoveMyNameActionMovePostResponses = {
    /**
     * The character has moved successfully.
     */
    200: CharacterMovementResponseSchema;
};

export type ActionMoveMyNameActionMovePostResponse = ActionMoveMyNameActionMovePostResponses[keyof ActionMoveMyNameActionMovePostResponses];

export type ActionTransitionMyNameActionTransitionPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/transition';
};

export type ActionTransitionMyNameActionTransitionPostErrors = {
    /**
     * Transition not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Insufficient gold for this transition.
     */
    492: ErrorResponseSchema;
    /**
     * Conditions not met.
     */
    496: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionTransitionMyNameActionTransitionPostError = ActionTransitionMyNameActionTransitionPostErrors[keyof ActionTransitionMyNameActionTransitionPostErrors];

export type ActionTransitionMyNameActionTransitionPostResponses = {
    /**
     * The character has transitioned successfully.
     */
    200: CharacterTransitionResponseSchema;
};

export type ActionTransitionMyNameActionTransitionPostResponse = ActionTransitionMyNameActionTransitionPostResponses[keyof ActionTransitionMyNameActionTransitionPostResponses];

export type ActionRestMyNameActionRestPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/rest';
};

export type ActionRestMyNameActionRestPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionRestMyNameActionRestPostError = ActionRestMyNameActionRestPostErrors[keyof ActionRestMyNameActionRestPostErrors];

export type ActionRestMyNameActionRestPostResponses = {
    /**
     * The character has rested successfully.
     */
    200: CharacterRestResponseSchema;
};

export type ActionRestMyNameActionRestPostResponse = ActionRestMyNameActionRestPostResponses[keyof ActionRestMyNameActionRestPostResponses];

export type ActionEquipItemMyNameActionEquipPostData = {
    body: EquipSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/equip';
};

export type ActionEquipItemMyNameActionEquipPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * The character does not have enough HP to unequip this item.
     */
    483: ErrorResponseSchema;
    /**
     * The character cannot equip more than 100 utilities in the same slot.
     */
    484: ErrorResponseSchema;
    /**
     * This item is already equipped.
     */
    485: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The equipment slot is not empty.
     */
    491: ErrorResponseSchema;
    /**
     * Conditions not met.
     */
    496: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionEquipItemMyNameActionEquipPostError = ActionEquipItemMyNameActionEquipPostErrors[keyof ActionEquipItemMyNameActionEquipPostErrors];

export type ActionEquipItemMyNameActionEquipPostResponses = {
    /**
     * The item has been successfully equipped on your character.
     */
    200: EquipmentResponseSchema;
};

export type ActionEquipItemMyNameActionEquipPostResponse = ActionEquipItemMyNameActionEquipPostResponses[keyof ActionEquipItemMyNameActionEquipPostResponses];

export type ActionUnequipItemMyNameActionUnequipPostData = {
    body: UnequipSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/unequip';
};

export type ActionUnequipItemMyNameActionUnequipPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * The character does not have enough HP to unequip this item.
     */
    483: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The equipment slot is empty.
     */
    491: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionUnequipItemMyNameActionUnequipPostError = ActionUnequipItemMyNameActionUnequipPostErrors[keyof ActionUnequipItemMyNameActionUnequipPostErrors];

export type ActionUnequipItemMyNameActionUnequipPostResponses = {
    /**
     * The item has been successfully unequipped and added in their inventory.
     */
    200: EquipmentResponseSchema;
};

export type ActionUnequipItemMyNameActionUnequipPostResponse = ActionUnequipItemMyNameActionUnequipPostResponses[keyof ActionUnequipItemMyNameActionUnequipPostResponses];

export type ActionUseItemMyNameActionUsePostData = {
    body: SimpleItemSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/use';
};

export type ActionUseItemMyNameActionUsePostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This item is not a consumable.
     */
    476: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Conditions not met.
     */
    496: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionUseItemMyNameActionUsePostError = ActionUseItemMyNameActionUsePostErrors[keyof ActionUseItemMyNameActionUsePostErrors];

export type ActionUseItemMyNameActionUsePostResponses = {
    /**
     * The item has been successfully used.
     */
    200: UseItemResponseSchema;
};

export type ActionUseItemMyNameActionUsePostResponse = ActionUseItemMyNameActionUsePostResponses[keyof ActionUseItemMyNameActionUsePostResponses];

export type ActionFightMyNameActionFightPostData = {
    /**
     * Fight Request
     */
    body?: FightRequestSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/fight';
};

export type ActionFightMyNameActionFightPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Only boss monsters can be fought by multiple characters.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Monster not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionFightMyNameActionFightPostError = ActionFightMyNameActionFightPostErrors[keyof ActionFightMyNameActionFightPostErrors];

export type ActionFightMyNameActionFightPostResponses = {
    /**
     * The fight ended successfully.
     */
    200: CharacterFightResponseSchema;
};

export type ActionFightMyNameActionFightPostResponse = ActionFightMyNameActionFightPostResponses[keyof ActionFightMyNameActionFightPostResponses];

export type ActionGatheringMyNameActionGatheringPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/gathering';
};

export type ActionGatheringMyNameActionGatheringPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's skill level is too low.
     */
    493: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Resource not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionGatheringMyNameActionGatheringPostError = ActionGatheringMyNameActionGatheringPostErrors[keyof ActionGatheringMyNameActionGatheringPostErrors];

export type ActionGatheringMyNameActionGatheringPostResponses = {
    /**
     * The resource has been successfully gathered.
     */
    200: SkillResponseSchema;
};

export type ActionGatheringMyNameActionGatheringPostResponse = ActionGatheringMyNameActionGatheringPostResponses[keyof ActionGatheringMyNameActionGatheringPostResponses];

export type ActionCraftingMyNameActionCraftingPostData = {
    body: CraftingSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/crafting';
};

export type ActionCraftingMyNameActionCraftingPostErrors = {
    /**
     * Craft not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's skill level is too low.
     */
    493: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Workshop not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionCraftingMyNameActionCraftingPostError = ActionCraftingMyNameActionCraftingPostErrors[keyof ActionCraftingMyNameActionCraftingPostErrors];

export type ActionCraftingMyNameActionCraftingPostResponses = {
    /**
     * The item was successfully crafted.
     */
    200: SkillResponseSchema;
};

export type ActionCraftingMyNameActionCraftingPostResponse = ActionCraftingMyNameActionCraftingPostResponses[keyof ActionCraftingMyNameActionCraftingPostResponses];

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostData = {
    body: DepositWithdrawGoldSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/bank/deposit/gold';
};

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Some of your items or your gold in the bank are already part of an ongoing transaction.
     */
    461: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Bank not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostError = ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors[keyof ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors];

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses = {
    /**
     * Golds successfully deposited in your bank.
     */
    200: BankGoldTransactionResponseSchema;
};

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostResponse = ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses[keyof ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses];

export type ActionDepositBankItemMyNameActionBankDepositItemPostData = {
    /**
     * Items
     *
     * List of items to deposit in the bank.
     */
    body: Array<SimpleItemSchema>;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/bank/deposit/item';
};

export type ActionDepositBankItemMyNameActionBankDepositItemPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Some of your items or your gold in the bank are already part of an ongoing transaction.
     */
    461: ErrorResponseSchema;
    /**
     * Your bank is full.
     */
    462: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Bank not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionDepositBankItemMyNameActionBankDepositItemPostError = ActionDepositBankItemMyNameActionBankDepositItemPostErrors[keyof ActionDepositBankItemMyNameActionBankDepositItemPostErrors];

export type ActionDepositBankItemMyNameActionBankDepositItemPostResponses = {
    /**
     * Items successfully deposited in your bank.
     */
    200: BankItemTransactionResponseSchema;
};

export type ActionDepositBankItemMyNameActionBankDepositItemPostResponse = ActionDepositBankItemMyNameActionBankDepositItemPostResponses[keyof ActionDepositBankItemMyNameActionBankDepositItemPostResponses];

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostData = {
    /**
     * Items
     */
    body: Array<SimpleItemSchema>;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/bank/withdraw/item';
};

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Some of your items or your gold in the bank are already part of an ongoing transaction.
     */
    461: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Bank not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostError = ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors[keyof ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors];

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses = {
    /**
     * Items successfully withdrawn from your bank.
     */
    200: BankItemTransactionResponseSchema;
};

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponse = ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses[keyof ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses];

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostData = {
    body: DepositWithdrawGoldSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/bank/withdraw/gold';
};

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Insufficient gold in your bank.
     */
    460: ErrorResponseSchema;
    /**
     * Some of your items or your gold in the bank are already part of an ongoing transaction.
     */
    461: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Bank not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError = ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors[keyof ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors];

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses = {
    /**
     * Golds successfully withdraw from your bank.
     */
    200: BankGoldTransactionResponseSchema;
};

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponse = ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses[keyof ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses];

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/bank/buy_expansion';
};

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Bank not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError = ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors[keyof ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors];

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses = {
    /**
     * Bank expansion successfully bought.
     */
    200: BankExtensionTransactionResponseSchema;
};

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponse = ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses[keyof ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses];

export type ActionNpcBuyItemMyNameActionNpcBuyPostData = {
    body: NpcMerchantBuySchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/npc/buy';
};

export type ActionNpcBuyItemMyNameActionNpcBuyPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This item is not available for purchase.
     */
    441: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * NPC not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionNpcBuyItemMyNameActionNpcBuyPostError = ActionNpcBuyItemMyNameActionNpcBuyPostErrors[keyof ActionNpcBuyItemMyNameActionNpcBuyPostErrors];

export type ActionNpcBuyItemMyNameActionNpcBuyPostResponses = {
    /**
     * Item successfully bought from the NPC.
     */
    200: NpcMerchantTransactionResponseSchema;
};

export type ActionNpcBuyItemMyNameActionNpcBuyPostResponse = ActionNpcBuyItemMyNameActionNpcBuyPostResponses[keyof ActionNpcBuyItemMyNameActionNpcBuyPostResponses];

export type ActionNpcSellItemMyNameActionNpcSellPostData = {
    body: NpcMerchantBuySchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/npc/sell';
};

export type ActionNpcSellItemMyNameActionNpcSellPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This item cannot be sold.
     */
    442: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * NPC not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionNpcSellItemMyNameActionNpcSellPostError = ActionNpcSellItemMyNameActionNpcSellPostErrors[keyof ActionNpcSellItemMyNameActionNpcSellPostErrors];

export type ActionNpcSellItemMyNameActionNpcSellPostResponses = {
    /**
     * Item successfully sold to the NPC.
     */
    200: NpcMerchantTransactionResponseSchema;
};

export type ActionNpcSellItemMyNameActionNpcSellPostResponse = ActionNpcSellItemMyNameActionNpcSellPostResponses[keyof ActionNpcSellItemMyNameActionNpcSellPostResponses];

export type ActionRecyclingMyNameActionRecyclingPostData = {
    body: RecyclingSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/recycling';
};

export type ActionRecyclingMyNameActionRecyclingPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This item cannot be recycled.
     */
    473: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's skill level is too low.
     */
    493: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Workshop not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionRecyclingMyNameActionRecyclingPostError = ActionRecyclingMyNameActionRecyclingPostErrors[keyof ActionRecyclingMyNameActionRecyclingPostErrors];

export type ActionRecyclingMyNameActionRecyclingPostResponses = {
    /**
     * The items were successfully recycled.
     */
    200: RecyclingResponseSchema;
};

export type ActionRecyclingMyNameActionRecyclingPostResponse = ActionRecyclingMyNameActionRecyclingPostResponses[keyof ActionRecyclingMyNameActionRecyclingPostResponses];

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostData = {
    body: GeBuyOrderSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/grandexchange/buy';
};

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors = {
    /**
     * Order not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This offer does not contain that many items.
     */
    434: ErrorResponseSchema;
    /**
     * You cannot trade with yourself.
     */
    435: ErrorResponseSchema;
    /**
     * A transaction is already in progress for this order by another character.
     */
    436: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Grand Exchange not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostError = ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors[keyof ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors];

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses = {
    /**
     * Item successfully bought from the Grand Exchange.
     */
    200: GeTransactionResponseSchema;
};

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponse = ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses[keyof ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses];

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostData = {
    body: GeOrderCreationrSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/grandexchange/sell';
};

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * You cannot create more than 100 orders at the same time.
     */
    433: ErrorResponseSchema;
    /**
     * This item cannot be sold.
     */
    437: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Grand Exchange not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError = ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors[keyof ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors];

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses = {
    /**
     * The sell order has been successfully created.
     */
    200: GeCreateOrderTransactionResponseSchema;
};

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponse = ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses[keyof ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses];

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostData = {
    body: GeCancelOrderSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/grandexchange/cancel';
};

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors = {
    /**
     * Order not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * A transaction is already in progress for this order by another character.
     */
    436: ErrorResponseSchema;
    /**
     * You cannot cancel an order that is not yours.
     */
    438: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Grand Exchange not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError = ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors[keyof ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors];

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses = {
    /**
     * Your sell order has been successfully cancelled.
     */
    200: GeTransactionResponseSchema;
};

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponse = ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses[keyof ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses];

export type ActionCompleteTaskMyNameActionTaskCompletePostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/task/complete';
};

export type ActionCompleteTaskMyNameActionTaskCompletePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character has no task assigned.
     */
    487: ErrorResponseSchema;
    /**
     * The character has not completed the task.
     */
    488: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Tasks Master not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionCompleteTaskMyNameActionTaskCompletePostError = ActionCompleteTaskMyNameActionTaskCompletePostErrors[keyof ActionCompleteTaskMyNameActionTaskCompletePostErrors];

export type ActionCompleteTaskMyNameActionTaskCompletePostResponses = {
    /**
     * The task has been successfully completed.
     */
    200: RewardDataResponseSchema;
};

export type ActionCompleteTaskMyNameActionTaskCompletePostResponse = ActionCompleteTaskMyNameActionTaskCompletePostResponses[keyof ActionCompleteTaskMyNameActionTaskCompletePostResponses];

export type ActionTaskExchangeMyNameActionTaskExchangePostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/task/exchange';
};

export type ActionTaskExchangeMyNameActionTaskExchangePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Tasks Master not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionTaskExchangeMyNameActionTaskExchangePostError = ActionTaskExchangeMyNameActionTaskExchangePostErrors[keyof ActionTaskExchangeMyNameActionTaskExchangePostErrors];

export type ActionTaskExchangeMyNameActionTaskExchangePostResponses = {
    /**
     * The tasks coins have been successfully exchanged.
     */
    200: RewardDataResponseSchema;
};

export type ActionTaskExchangeMyNameActionTaskExchangePostResponse = ActionTaskExchangeMyNameActionTaskExchangePostResponses[keyof ActionTaskExchangeMyNameActionTaskExchangePostResponses];

export type ActionAcceptNewTaskMyNameActionTaskNewPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/task/new';
};

export type ActionAcceptNewTaskMyNameActionTaskNewPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character already has an assigned task.
     */
    489: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Tasks Master not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionAcceptNewTaskMyNameActionTaskNewPostError = ActionAcceptNewTaskMyNameActionTaskNewPostErrors[keyof ActionAcceptNewTaskMyNameActionTaskNewPostErrors];

export type ActionAcceptNewTaskMyNameActionTaskNewPostResponses = {
    /**
     * New task successfully accepted.
     */
    200: TaskResponseSchema;
};

export type ActionAcceptNewTaskMyNameActionTaskNewPostResponse = ActionAcceptNewTaskMyNameActionTaskNewPostResponses[keyof ActionAcceptNewTaskMyNameActionTaskNewPostResponses];

export type ActionTaskTradeMyNameActionTaskTradePostData = {
    body: SimpleItemSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/task/trade';
};

export type ActionTaskTradeMyNameActionTaskTradePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * The character does not have this task.
     */
    474: ErrorResponseSchema;
    /**
     * Task already completed or too many items submitted.
     */
    475: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Tasks Master not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionTaskTradeMyNameActionTaskTradePostError = ActionTaskTradeMyNameActionTaskTradePostErrors[keyof ActionTaskTradeMyNameActionTaskTradePostErrors];

export type ActionTaskTradeMyNameActionTaskTradePostResponses = {
    /**
     * You have successfully trade items to a Tasks Master.
     */
    200: TaskTradeResponseSchema;
};

export type ActionTaskTradeMyNameActionTaskTradePostResponse = ActionTaskTradeMyNameActionTaskTradePostResponses[keyof ActionTaskTradeMyNameActionTaskTradePostResponses];

export type ActionTaskCancelMyNameActionTaskCancelPostData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/task/cancel';
};

export type ActionTaskCancelMyNameActionTaskCancelPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * Tasks Master not found on this map.
     */
    598: ErrorResponseSchema;
};

export type ActionTaskCancelMyNameActionTaskCancelPostError = ActionTaskCancelMyNameActionTaskCancelPostErrors[keyof ActionTaskCancelMyNameActionTaskCancelPostErrors];

export type ActionTaskCancelMyNameActionTaskCancelPostResponses = {
    /**
     * The task has been successfully cancelled.
     */
    200: TaskCancelledResponseSchema;
};

export type ActionTaskCancelMyNameActionTaskCancelPostResponse = ActionTaskCancelMyNameActionTaskCancelPostResponses[keyof ActionTaskCancelMyNameActionTaskCancelPostResponses];

export type ActionGiveGoldMyNameActionGiveGoldPostData = {
    body: GiveGoldSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/give/gold';
};

export type ActionGiveGoldMyNameActionGiveGoldPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character does not have enough gold.
     */
    492: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionGiveGoldMyNameActionGiveGoldPostError = ActionGiveGoldMyNameActionGiveGoldPostErrors[keyof ActionGiveGoldMyNameActionGiveGoldPostErrors];

export type ActionGiveGoldMyNameActionGiveGoldPostResponses = {
    /**
     * Gold given successfully.
     */
    200: GiveGoldResponseSchema;
};

export type ActionGiveGoldMyNameActionGiveGoldPostResponse = ActionGiveGoldMyNameActionGiveGoldPostResponses[keyof ActionGiveGoldMyNameActionGiveGoldPostResponses];

export type ActionGiveItemsMyNameActionGiveItemPostData = {
    body: GiveItemsSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/give/item';
};

export type ActionGiveItemsMyNameActionGiveItemPostErrors = {
    /**
     * Item not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character's inventory is full.
     */
    497: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionGiveItemsMyNameActionGiveItemPostError = ActionGiveItemsMyNameActionGiveItemPostErrors[keyof ActionGiveItemsMyNameActionGiveItemPostErrors];

export type ActionGiveItemsMyNameActionGiveItemPostResponses = {
    /**
     * Items given successfully.
     */
    200: GiveItemResponseSchema;
};

export type ActionGiveItemsMyNameActionGiveItemPostResponse = ActionGiveItemsMyNameActionGiveItemPostResponses[keyof ActionGiveItemsMyNameActionGiveItemPostResponses];

export type ActionDeleteItemMyNameActionDeletePostData = {
    body: SimpleItemSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/delete';
};

export type ActionDeleteItemMyNameActionDeletePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Missing required item(s).
     */
    478: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
};

export type ActionDeleteItemMyNameActionDeletePostError = ActionDeleteItemMyNameActionDeletePostErrors[keyof ActionDeleteItemMyNameActionDeletePostErrors];

export type ActionDeleteItemMyNameActionDeletePostResponses = {
    /**
     * Item successfully deleted from your character.
     */
    200: DeleteItemResponseSchema;
};

export type ActionDeleteItemMyNameActionDeletePostResponse = ActionDeleteItemMyNameActionDeletePostResponses[keyof ActionDeleteItemMyNameActionDeletePostResponses];

export type ActionChangeSkinMyNameActionChangeSkinPostData = {
    body: ChangeSkinCharacterSchema;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: never;
    url: '/my/{name}/action/change_skin';
};

export type ActionChangeSkinMyNameActionChangeSkinPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * An action is already in progress for this character.
     */
    486: ErrorResponseSchema;
    /**
     * The character is in cooldown.
     */
    499: ErrorResponseSchema;
    /**
     * You cannot choose this skin because you do not own it.
     */
    550: ErrorResponseSchema;
};

export type ActionChangeSkinMyNameActionChangeSkinPostError = ActionChangeSkinMyNameActionChangeSkinPostErrors[keyof ActionChangeSkinMyNameActionChangeSkinPostErrors];

export type ActionChangeSkinMyNameActionChangeSkinPostResponses = {
    /**
     * Skin successfully changed.
     */
    200: ChangeSkinResponseSchema;
};

export type ActionChangeSkinMyNameActionChangeSkinPostResponse = ActionChangeSkinMyNameActionChangeSkinPostResponses[keyof ActionChangeSkinMyNameActionChangeSkinPostResponses];

export type GetAllCharactersLogsMyLogsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/my/logs';
};

export type GetAllCharactersLogsMyLogsGetErrors = {
    /**
     * Logs not found.
     */
    404: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
};

export type GetAllCharactersLogsMyLogsGetError = GetAllCharactersLogsMyLogsGetErrors[keyof GetAllCharactersLogsMyLogsGetErrors];

export type GetAllCharactersLogsMyLogsGetResponses = {
    /**
     * Successfully fetched logs.
     */
    200: DataPageLogSchema;
};

export type GetAllCharactersLogsMyLogsGetResponse = GetAllCharactersLogsMyLogsGetResponses[keyof GetAllCharactersLogsMyLogsGetResponses];

export type GetCharacterLogsMyLogsNameGetData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * Name of your character.
         */
        name: string;
    };
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/my/logs/{name}';
};

export type GetCharacterLogsMyLogsNameGetErrors = {
    /**
     * Logs not found.
     */
    404: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
};

export type GetCharacterLogsMyLogsNameGetError = GetCharacterLogsMyLogsNameGetErrors[keyof GetCharacterLogsMyLogsNameGetErrors];

export type GetCharacterLogsMyLogsNameGetResponses = {
    /**
     * Successfully fetched logs.
     */
    200: DataPageLogSchema;
};

export type GetCharacterLogsMyLogsNameGetResponse = GetCharacterLogsMyLogsNameGetResponses[keyof GetCharacterLogsMyLogsNameGetResponses];

export type GetMyCharactersMyCharactersGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/my/characters';
};

export type GetMyCharactersMyCharactersGetResponses = {
    /**
     * Successfully fetched data.
     */
    200: MyCharactersListSchema;
};

export type GetMyCharactersMyCharactersGetResponse = GetMyCharactersMyCharactersGetResponses[keyof GetMyCharactersMyCharactersGetResponses];

export type CreateAccountAccountsCreatePostData = {
    body: AddAccountSchema;
    path?: never;
    query?: never;
    url: '/accounts/create';
};

export type CreateAccountAccountsCreatePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This username is already taken.
     */
    456: ErrorResponseSchema;
    /**
     * This email is already in use.
     */
    457: ErrorResponseSchema;
};

export type CreateAccountAccountsCreatePostError = CreateAccountAccountsCreatePostErrors[keyof CreateAccountAccountsCreatePostErrors];

export type CreateAccountAccountsCreatePostResponses = {
    /**
     * Account created successfully.
     */
    200: ResponseSchema;
};

export type CreateAccountAccountsCreatePostResponse = CreateAccountAccountsCreatePostResponses[keyof CreateAccountAccountsCreatePostResponses];

export type ForgotPasswordAccountsForgotPasswordPostData = {
    body: PasswordResetRequestSchema;
    path?: never;
    query?: never;
    url: '/accounts/forgot_password';
};

export type ForgotPasswordAccountsForgotPasswordPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
};

export type ForgotPasswordAccountsForgotPasswordPostError = ForgotPasswordAccountsForgotPasswordPostErrors[keyof ForgotPasswordAccountsForgotPasswordPostErrors];

export type ForgotPasswordAccountsForgotPasswordPostResponses = {
    /**
     * If this email address is associated with an account, a reset link has been sent.
     */
    200: PasswordResetResponseSchema;
};

export type ForgotPasswordAccountsForgotPasswordPostResponse = ForgotPasswordAccountsForgotPasswordPostResponses[keyof ForgotPasswordAccountsForgotPasswordPostResponses];

export type ResetPasswordAccountsResetPasswordPostData = {
    body: PasswordResetConfirmSchema;
    path?: never;
    query?: never;
    url: '/accounts/reset_password';
};

export type ResetPasswordAccountsResetPasswordPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * The password reset token is invalid.
     */
    560: ErrorResponseSchema;
    /**
     * The password reset token has expired.
     */
    561: ErrorResponseSchema;
    /**
     * This password reset token has already been used.
     */
    562: ErrorResponseSchema;
};

export type ResetPasswordAccountsResetPasswordPostError = ResetPasswordAccountsResetPasswordPostErrors[keyof ResetPasswordAccountsResetPasswordPostErrors];

export type ResetPasswordAccountsResetPasswordPostResponses = {
    /**
     * Password has been successfully reset.
     */
    200: PasswordResetResponseSchema;
};

export type ResetPasswordAccountsResetPasswordPostResponse = ResetPasswordAccountsResetPasswordPostResponses[keyof ResetPasswordAccountsResetPasswordPostResponses];

export type GetAccountAchievementsAccountsAccountAchievementsGetData = {
    body?: never;
    path: {
        /**
         * Account name
         *
         * The name of the account.
         */
        account: string;
    };
    query?: {
        /**
         * Type
         *
         * Type of achievements.
         */
        type?: AchievementType;
        /**
         * Completed
         *
         * Filter by completed achievements.
         */
        completed?: boolean;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/accounts/{account}/achievements';
};

export type GetAccountAchievementsAccountsAccountAchievementsGetErrors = {
    /**
     * Account not found.
     */
    404: ErrorResponseSchema;
};

export type GetAccountAchievementsAccountsAccountAchievementsGetError = GetAccountAchievementsAccountsAccountAchievementsGetErrors[keyof GetAccountAchievementsAccountsAccountAchievementsGetErrors];

export type GetAccountAchievementsAccountsAccountAchievementsGetResponses = {
    /**
     * Successfully fetched achievements.
     */
    200: DataPageAccountAchievementSchema;
};

export type GetAccountAchievementsAccountsAccountAchievementsGetResponse = GetAccountAchievementsAccountsAccountAchievementsGetResponses[keyof GetAccountAchievementsAccountsAccountAchievementsGetResponses];

export type GetAccountCharactersAccountsAccountCharactersGetData = {
    body?: never;
    path: {
        /**
         * Account name
         *
         * The name of the account.
         */
        account: string;
    };
    query?: never;
    url: '/accounts/{account}/characters';
};

export type GetAccountCharactersAccountsAccountCharactersGetResponses = {
    /**
     * Successfully fetched account characters.
     */
    200: CharactersListSchema;
};

export type GetAccountCharactersAccountsAccountCharactersGetResponse = GetAccountCharactersAccountsAccountCharactersGetResponses[keyof GetAccountCharactersAccountsAccountCharactersGetResponses];

export type GetAccountAccountsAccountGetData = {
    body?: never;
    path: {
        /**
         * Account name
         *
         * The name of the account.
         */
        account: string;
    };
    query?: never;
    url: '/accounts/{account}';
};

export type GetAccountAccountsAccountGetErrors = {
    /**
     * account not found.
     */
    404: ErrorResponseSchema;
};

export type GetAccountAccountsAccountGetError = GetAccountAccountsAccountGetErrors[keyof GetAccountAccountsAccountGetErrors];

export type GetAccountAccountsAccountGetResponses = {
    /**
     * Successfully fetched account.
     */
    200: AccountDetailsSchema;
};

export type GetAccountAccountsAccountGetResponse = GetAccountAccountsAccountGetResponses[keyof GetAccountAccountsAccountGetResponses];

export type GetAllAchievementsAchievementsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Type
         *
         * Type of achievements.
         */
        type?: AchievementType;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/achievements';
};

export type GetAllAchievementsAchievementsGetResponses = {
    /**
     * Successfully fetched achievements.
     */
    200: DataPageAchievementSchema;
};

export type GetAllAchievementsAchievementsGetResponse = GetAllAchievementsAchievementsGetResponses[keyof GetAllAchievementsAchievementsGetResponses];

export type GetAchievementAchievementsCodeGetData = {
    body?: never;
    path: {
        /**
         * Achievement code
         *
         * The code of the achievement.
         */
        code: string;
    };
    query?: never;
    url: '/achievements/{code}';
};

export type GetAchievementAchievementsCodeGetErrors = {
    /**
     * achievement not found.
     */
    404: ErrorResponseSchema;
};

export type GetAchievementAchievementsCodeGetError = GetAchievementAchievementsCodeGetErrors[keyof GetAchievementAchievementsCodeGetErrors];

export type GetAchievementAchievementsCodeGetResponses = {
    /**
     * Successfully fetched achievement.
     */
    200: AchievementResponseSchema;
};

export type GetAchievementAchievementsCodeGetResponse = GetAchievementAchievementsCodeGetResponses[keyof GetAchievementAchievementsCodeGetResponses];

export type GetAllBadgesBadgesGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/badges';
};

export type GetAllBadgesBadgesGetResponses = {
    /**
     * Successfully fetched badges.
     */
    200: DataPageBadgeSchema;
};

export type GetAllBadgesBadgesGetResponse = GetAllBadgesBadgesGetResponses[keyof GetAllBadgesBadgesGetResponses];

export type GetBadgeBadgesCodeGetData = {
    body?: never;
    path: {
        /**
         * Badge code
         *
         * The code of the badge.
         */
        code: string;
    };
    query?: never;
    url: '/badges/{code}';
};

export type GetBadgeBadgesCodeGetErrors = {
    /**
     * badge not found.
     */
    404: ErrorResponseSchema;
};

export type GetBadgeBadgesCodeGetError = GetBadgeBadgesCodeGetErrors[keyof GetBadgeBadgesCodeGetErrors];

export type GetBadgeBadgesCodeGetResponses = {
    /**
     * Successfully fetched badge.
     */
    200: BadgeResponseSchema;
};

export type GetBadgeBadgesCodeGetResponse = GetBadgeBadgesCodeGetResponses[keyof GetBadgeBadgesCodeGetResponses];

export type CreateCharacterCharactersCreatePostData = {
    body: AddCharacterSchema;
    path?: never;
    query?: never;
    url: '/characters/create';
};

export type CreateCharacterCharactersCreatePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * This name is already in use.
     */
    494: ErrorResponseSchema;
    /**
     * You have reached the maximum number of characters on your account.
     */
    495: ErrorResponseSchema;
    /**
     * You cannot choose this skin because you do not own it.
     */
    550: ErrorResponseSchema;
};

export type CreateCharacterCharactersCreatePostError = CreateCharacterCharactersCreatePostErrors[keyof CreateCharacterCharactersCreatePostErrors];

export type CreateCharacterCharactersCreatePostResponses = {
    /**
     * Successfully created character.
     */
    200: CharacterResponseSchema;
};

export type CreateCharacterCharactersCreatePostResponse = CreateCharacterCharactersCreatePostResponses[keyof CreateCharacterCharactersCreatePostResponses];

export type DeleteCharacterCharactersDeletePostData = {
    body: DeleteCharacterSchema;
    path?: never;
    query?: never;
    url: '/characters/delete';
};

export type DeleteCharacterCharactersDeletePostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Character not found.
     */
    498: ErrorResponseSchema;
};

export type DeleteCharacterCharactersDeletePostError = DeleteCharacterCharactersDeletePostErrors[keyof DeleteCharacterCharactersDeletePostErrors];

export type DeleteCharacterCharactersDeletePostResponses = {
    /**
     * Successfully deleted character.
     */
    200: CharacterResponseSchema;
};

export type DeleteCharacterCharactersDeletePostResponse = DeleteCharacterCharactersDeletePostResponses[keyof DeleteCharacterCharactersDeletePostResponses];

export type GetActiveCharactersCharactersActiveGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/characters/active';
};

export type GetActiveCharactersCharactersActiveGetResponses = {
    /**
     * Successfully fetched active characters.
     */
    200: DataPageActiveCharacterSchema;
};

export type GetActiveCharactersCharactersActiveGetResponse = GetActiveCharactersCharactersActiveGetResponses[keyof GetActiveCharactersCharactersActiveGetResponses];

export type GetCharacterCharactersNameGetData = {
    body?: never;
    path: {
        /**
         * Character name
         *
         * The name of the character.
         */
        name: string;
    };
    query?: never;
    url: '/characters/{name}';
};

export type GetCharacterCharactersNameGetErrors = {
    /**
     * character not found.
     */
    404: ErrorResponseSchema;
};

export type GetCharacterCharactersNameGetError = GetCharacterCharactersNameGetErrors[keyof GetCharacterCharactersNameGetErrors];

export type GetCharacterCharactersNameGetResponses = {
    /**
     * Successfully fetched character.
     */
    200: CharacterResponseSchema;
};

export type GetCharacterCharactersNameGetResponse = GetCharacterCharactersNameGetResponses[keyof GetCharacterCharactersNameGetResponses];

export type GetAllEffectsEffectsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/effects';
};

export type GetAllEffectsEffectsGetResponses = {
    /**
     * Successfully fetched effects.
     */
    200: DataPageEffectSchema;
};

export type GetAllEffectsEffectsGetResponse = GetAllEffectsEffectsGetResponses[keyof GetAllEffectsEffectsGetResponses];

export type GetEffectEffectsCodeGetData = {
    body?: never;
    path: {
        /**
         * Effect code
         *
         * The code of the effect.
         */
        code: string;
    };
    query?: never;
    url: '/effects/{code}';
};

export type GetEffectEffectsCodeGetErrors = {
    /**
     * effect not found.
     */
    404: ErrorResponseSchema;
};

export type GetEffectEffectsCodeGetError = GetEffectEffectsCodeGetErrors[keyof GetEffectEffectsCodeGetErrors];

export type GetEffectEffectsCodeGetResponses = {
    /**
     * Successfully fetched effect.
     */
    200: EffectResponseSchema;
};

export type GetEffectEffectsCodeGetResponse = GetEffectEffectsCodeGetResponses[keyof GetEffectEffectsCodeGetResponses];

export type GetAllActiveEventsEventsActiveGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/events/active';
};

export type GetAllActiveEventsEventsActiveGetResponses = {
    /**
     * Successfully fetched active events.
     */
    200: DataPageActiveEventSchema;
};

export type GetAllActiveEventsEventsActiveGetResponse = GetAllActiveEventsEventsActiveGetResponses[keyof GetAllActiveEventsEventsActiveGetResponses];

export type GetAllEventsEventsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Type
         *
         * Type of events.
         */
        type?: MapContentType;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/events';
};

export type GetAllEventsEventsGetResponses = {
    /**
     * Successfully fetched events.
     */
    200: DataPageEventSchema;
};

export type GetAllEventsEventsGetResponse = GetAllEventsEventsGetResponses[keyof GetAllEventsEventsGetResponses];

export type SpawnEventEventsSpawnPostData = {
    body: SpawnEventRequest;
    path?: never;
    query?: never;
    url: '/events/spawn';
};

export type SpawnEventEventsSpawnPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Access denied, you must be a member to do that.
     */
    451: ErrorResponseSchema;
    /**
     * Insufficient event tokens. You need at least 1 event token to spawn an event.
     */
    563: ErrorResponseSchema;
    /**
     * Event not found or already active.
     */
    564: ErrorResponseSchema;
};

export type SpawnEventEventsSpawnPostError = SpawnEventEventsSpawnPostErrors[keyof SpawnEventEventsSpawnPostErrors];

export type SpawnEventEventsSpawnPostResponses = {
    /**
     * Successfully fetched data.
     */
    200: ActiveEventResponseSchema;
};

export type SpawnEventEventsSpawnPostResponse = SpawnEventEventsSpawnPostResponses[keyof SpawnEventEventsSpawnPostResponses];

export type GetGeSellHistoryGrandexchangeHistoryCodeGetData = {
    body?: never;
    path: {
        /**
         * Item code
         *
         * The code of the item.
         */
        code: string;
    };
    query?: {
        /**
         * Seller
         *
         * The seller (account name) of the item.
         */
        seller?: string;
        /**
         * Buyer
         *
         * The buyer (account name) of the item.
         */
        buyer?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/grandexchange/history/{code}';
};

export type GetGeSellHistoryGrandexchangeHistoryCodeGetErrors = {
    /**
     * item history not found.
     */
    404: ErrorResponseSchema;
};

export type GetGeSellHistoryGrandexchangeHistoryCodeGetError = GetGeSellHistoryGrandexchangeHistoryCodeGetErrors[keyof GetGeSellHistoryGrandexchangeHistoryCodeGetErrors];

export type GetGeSellHistoryGrandexchangeHistoryCodeGetResponses = {
    /**
     * Successfully fetched item history.
     */
    200: DataPageGeOrderHistorySchema;
};

export type GetGeSellHistoryGrandexchangeHistoryCodeGetResponse = GetGeSellHistoryGrandexchangeHistoryCodeGetResponses[keyof GetGeSellHistoryGrandexchangeHistoryCodeGetResponses];

export type GetGeSellOrdersGrandexchangeOrdersGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item code
         *
         * The code of the item.
         */
        code?: string;
        /**
         * Seller
         *
         * The seller (account name) of the item.
         */
        seller?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/grandexchange/orders';
};

export type GetGeSellOrdersGrandexchangeOrdersGetResponses = {
    /**
     * Successfully fetched GE orders.
     */
    200: DataPageGeOrderSchema;
};

export type GetGeSellOrdersGrandexchangeOrdersGetResponse = GetGeSellOrdersGrandexchangeOrdersGetResponses[keyof GetGeSellOrdersGrandexchangeOrdersGetResponses];

export type GetGeSellOrderGrandexchangeOrdersIdGetData = {
    body?: never;
    path: {
        /**
         * Order id
         *
         * The id of the order.
         */
        id: string;
    };
    query?: never;
    url: '/grandexchange/orders/{id}';
};

export type GetGeSellOrderGrandexchangeOrdersIdGetErrors = {
    /**
     * GE order not found.
     */
    404: ErrorResponseSchema;
};

export type GetGeSellOrderGrandexchangeOrdersIdGetError = GetGeSellOrderGrandexchangeOrdersIdGetErrors[keyof GetGeSellOrderGrandexchangeOrdersIdGetErrors];

export type GetGeSellOrderGrandexchangeOrdersIdGetResponses = {
    /**
     * Successfully fetched GE order.
     */
    200: GeOrderResponseSchema;
};

export type GetGeSellOrderGrandexchangeOrdersIdGetResponse = GetGeSellOrderGrandexchangeOrdersIdGetResponses[keyof GetGeSellOrderGrandexchangeOrdersIdGetResponses];

export type GetAllItemsItemsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item name
         *
         * Name of the item.
         */
        name?: string;
        /**
         * Minimum level
         *
         * Minimum level.
         */
        min_level?: number;
        /**
         * Maximum level
         *
         * Maximum level.
         */
        max_level?: number;
        /**
         * Type
         *
         * Type of items.
         */
        type?: ItemType;
        /**
         * Crafting skill
         *
         * Skill to craft items.
         */
        craft_skill?: CraftSkill;
        /**
         * Crafting material
         *
         * Item code of items used as material for crafting.
         */
        craft_material?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/items';
};

export type GetAllItemsItemsGetResponses = {
    /**
     * Successfully fetched items.
     */
    200: DataPageItemSchema;
};

export type GetAllItemsItemsGetResponse = GetAllItemsItemsGetResponses[keyof GetAllItemsItemsGetResponses];

export type GetItemItemsCodeGetData = {
    body?: never;
    path: {
        /**
         * Item code
         *
         * The code of the item.
         */
        code: string;
    };
    query?: never;
    url: '/items/{code}';
};

export type GetItemItemsCodeGetErrors = {
    /**
     * item not found.
     */
    404: ErrorResponseSchema;
};

export type GetItemItemsCodeGetError = GetItemItemsCodeGetErrors[keyof GetItemItemsCodeGetErrors];

export type GetItemItemsCodeGetResponses = {
    /**
     * Successfully fetched item.
     */
    200: ItemResponseSchema;
};

export type GetItemItemsCodeGetResponse = GetItemItemsCodeGetResponses[keyof GetItemItemsCodeGetResponses];

export type GetCharactersLeaderboardLeaderboardCharactersGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Sort
         *
         * Sort of character leaderboards.
         */
        sort?: CharacterLeaderboardType;
        /**
         * Name
         *
         * Character name.
         */
        name?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/leaderboard/characters';
};

export type GetCharactersLeaderboardLeaderboardCharactersGetResponses = {
    /**
     * Successfully fetched leaderboard.
     */
    200: DataPageCharacterLeaderboardSchema;
};

export type GetCharactersLeaderboardLeaderboardCharactersGetResponse = GetCharactersLeaderboardLeaderboardCharactersGetResponses[keyof GetCharactersLeaderboardLeaderboardCharactersGetResponses];

export type GetAccountsLeaderboardLeaderboardAccountsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Sort
         *
         * Sort of account leaderboards.
         */
        sort?: AccountLeaderboardType;
        /**
         * Name
         *
         * Account name.
         */
        name?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/leaderboard/accounts';
};

export type GetAccountsLeaderboardLeaderboardAccountsGetResponses = {
    /**
     * Successfully fetched leaderboard.
     */
    200: DataPageAccountLeaderboardSchema;
};

export type GetAccountsLeaderboardLeaderboardAccountsGetResponse = GetAccountsLeaderboardLeaderboardAccountsGetResponses[keyof GetAccountsLeaderboardLeaderboardAccountsGetResponses];

export type GetAllMapsMapsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Map Layer
         *
         * Filter maps by layer.
         */
        layer?: MapLayer;
        /**
         * Map
         *
         * Type of maps.
         */
        content_type?: MapContentType;
        /**
         * Content code
         *
         * Content code on the map.
         */
        content_code?: string;
        /**
         * Hide blocked maps
         *
         * When true, excludes maps with access_type 'blocked' from the results.
         */
        hide_blocked_maps?: boolean;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/maps';
};

export type GetAllMapsMapsGetResponses = {
    /**
     * Successfully fetched maps.
     */
    200: DataPageMapSchema;
};

export type GetAllMapsMapsGetResponse = GetAllMapsMapsGetResponses[keyof GetAllMapsMapsGetResponses];

export type GetLayerMapsMapsLayerGetData = {
    body?: never;
    path: {
        /**
         * Map Layer
         *
         * The layer of the map (interior, overworld, underground).
         */
        layer: MapLayer;
    };
    query?: {
        /**
         * Map
         *
         * Type of maps.
         */
        content_type?: MapContentType;
        /**
         * Content code
         *
         * Content code on the map.
         */
        content_code?: string;
        /**
         * Hide blocked maps
         *
         * When true, excludes maps with access_type 'blocked' from the results.
         */
        hide_blocked_maps?: boolean;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/maps/{layer}';
};

export type GetLayerMapsMapsLayerGetResponses = {
    /**
     * Successfully fetched maps.
     */
    200: DataPageMapSchema;
};

export type GetLayerMapsMapsLayerGetResponse = GetLayerMapsMapsLayerGetResponses[keyof GetLayerMapsMapsLayerGetResponses];

export type GetMapByPositionMapsLayerXyGetData = {
    body?: never;
    path: {
        /**
         * Map Layer
         *
         * The layer of the map (interior, overworld, underground).
         */
        layer: MapLayer;
        /**
         * Position X
         *
         * The position x of the map.
         */
        x: number;
        /**
         * Position Y
         *
         * The position y of the map.
         */
        y: number;
    };
    query?: never;
    url: '/maps/{layer}/{x}/{y}';
};

export type GetMapByPositionMapsLayerXyGetErrors = {
    /**
     * map not found.
     */
    404: ErrorResponseSchema;
};

export type GetMapByPositionMapsLayerXyGetError = GetMapByPositionMapsLayerXyGetErrors[keyof GetMapByPositionMapsLayerXyGetErrors];

export type GetMapByPositionMapsLayerXyGetResponses = {
    /**
     * Successfully fetched map.
     */
    200: MapResponseSchema;
};

export type GetMapByPositionMapsLayerXyGetResponse = GetMapByPositionMapsLayerXyGetResponses[keyof GetMapByPositionMapsLayerXyGetResponses];

export type GetMapByIdMapsIdMapIdGetData = {
    body?: never;
    path: {
        /**
         * Map ID
         *
         * The unique ID of the map.
         */
        map_id: number;
    };
    query?: never;
    url: '/maps/id/{map_id}';
};

export type GetMapByIdMapsIdMapIdGetErrors = {
    /**
     * map not found.
     */
    404: ErrorResponseSchema;
};

export type GetMapByIdMapsIdMapIdGetError = GetMapByIdMapsIdMapIdGetErrors[keyof GetMapByIdMapsIdMapIdGetErrors];

export type GetMapByIdMapsIdMapIdGetResponses = {
    /**
     * Successfully fetched map.
     */
    200: MapResponseSchema;
};

export type GetMapByIdMapsIdMapIdGetResponse = GetMapByIdMapsIdMapIdGetResponses[keyof GetMapByIdMapsIdMapIdGetResponses];

export type GetAllMonstersMonstersGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Monster name
         *
         * Name of the monster.
         */
        name?: string;
        /**
         * Minimum level
         *
         * Minimum level.
         */
        min_level?: number;
        /**
         * Maximum level
         *
         * Maximum level.
         */
        max_level?: number;
        /**
         * Drop
         *
         * Item code of the drop.
         */
        drop?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/monsters';
};

export type GetAllMonstersMonstersGetResponses = {
    /**
     * Successfully fetched monsters.
     */
    200: DataPageMonsterSchema;
};

export type GetAllMonstersMonstersGetResponse = GetAllMonstersMonstersGetResponses[keyof GetAllMonstersMonstersGetResponses];

export type GetMonsterMonstersCodeGetData = {
    body?: never;
    path: {
        /**
         * Monster code
         *
         * The code of the monster.
         */
        code: string;
    };
    query?: never;
    url: '/monsters/{code}';
};

export type GetMonsterMonstersCodeGetErrors = {
    /**
     * monster not found.
     */
    404: ErrorResponseSchema;
};

export type GetMonsterMonstersCodeGetError = GetMonsterMonstersCodeGetErrors[keyof GetMonsterMonstersCodeGetErrors];

export type GetMonsterMonstersCodeGetResponses = {
    /**
     * Successfully fetched monster.
     */
    200: MonsterResponseSchema;
};

export type GetMonsterMonstersCodeGetResponse = GetMonsterMonstersCodeGetResponses[keyof GetMonsterMonstersCodeGetResponses];

export type GetAllNpcsNpcsDetailsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Name
         *
         * NPC name.
         */
        name?: string;
        /**
         * Type
         *
         * Type of NPCs.
         */
        type?: NpcType;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/npcs/details';
};

export type GetAllNpcsNpcsDetailsGetResponses = {
    /**
     * Successfully fetched NPCs.
     */
    200: DataPageNpcSchema;
};

export type GetAllNpcsNpcsDetailsGetResponse = GetAllNpcsNpcsDetailsGetResponses[keyof GetAllNpcsNpcsDetailsGetResponses];

export type GetNpcNpcsDetailsCodeGetData = {
    body?: never;
    path: {
        /**
         * Npc code
         *
         * The code of the NPC.
         */
        code: string;
    };
    query?: never;
    url: '/npcs/details/{code}';
};

export type GetNpcNpcsDetailsCodeGetErrors = {
    /**
     * NPC not found.
     */
    404: ErrorResponseSchema;
};

export type GetNpcNpcsDetailsCodeGetError = GetNpcNpcsDetailsCodeGetErrors[keyof GetNpcNpcsDetailsCodeGetErrors];

export type GetNpcNpcsDetailsCodeGetResponses = {
    /**
     * Successfully fetched NPC.
     */
    200: NpcResponseSchema;
};

export type GetNpcNpcsDetailsCodeGetResponse = GetNpcNpcsDetailsCodeGetResponses[keyof GetNpcNpcsDetailsCodeGetResponses];

export type GetNpcItemsNpcsItemsCodeGetData = {
    body?: never;
    path: {
        /**
         * Npc code
         *
         * The code of the NPC.
         */
        code: string;
    };
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/npcs/items/{code}';
};

export type GetNpcItemsNpcsItemsCodeGetErrors = {
    /**
     * NPC items not found.
     */
    404: ErrorResponseSchema;
};

export type GetNpcItemsNpcsItemsCodeGetError = GetNpcItemsNpcsItemsCodeGetErrors[keyof GetNpcItemsNpcsItemsCodeGetErrors];

export type GetNpcItemsNpcsItemsCodeGetResponses = {
    /**
     * Successfully fetched NPC items.
     */
    200: DataPageNpcItem;
};

export type GetNpcItemsNpcsItemsCodeGetResponse = GetNpcItemsNpcsItemsCodeGetResponses[keyof GetNpcItemsNpcsItemsCodeGetResponses];

export type GetAllNpcsItemsNpcsItemsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item code
         *
         * Item code.
         */
        code?: string;
        /**
         * NPC code
         *
         * NPC code.
         */
        npc?: string;
        /**
         * Currency code
         *
         * Currency code.
         */
        currency?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/npcs/items';
};

export type GetAllNpcsItemsNpcsItemsGetResponses = {
    /**
     * Successfully fetched NPC items.
     */
    200: DataPageNpcItem;
};

export type GetAllNpcsItemsNpcsItemsGetResponse = GetAllNpcsItemsNpcsItemsGetResponses[keyof GetAllNpcsItemsNpcsItemsGetResponses];

export type GetAllResourcesResourcesGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Minimum level
         *
         * Minimum level.
         */
        min_level?: number;
        /**
         * Maximum level
         *
         * Maximum level.
         */
        max_level?: number;
        /**
         * Skill
         *
         * Skill of resources.
         */
        skill?: GatheringSkill;
        /**
         * Drop
         *
         * Item code of the drop.
         */
        drop?: string;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/resources';
};

export type GetAllResourcesResourcesGetResponses = {
    /**
     * Successfully fetched resources.
     */
    200: DataPageResourceSchema;
};

export type GetAllResourcesResourcesGetResponse = GetAllResourcesResourcesGetResponses[keyof GetAllResourcesResourcesGetResponses];

export type GetResourceResourcesCodeGetData = {
    body?: never;
    path: {
        /**
         * Resource code
         *
         * The code of the resource.
         */
        code: string;
    };
    query?: never;
    url: '/resources/{code}';
};

export type GetResourceResourcesCodeGetErrors = {
    /**
     * resource not found.
     */
    404: ErrorResponseSchema;
};

export type GetResourceResourcesCodeGetError = GetResourceResourcesCodeGetErrors[keyof GetResourceResourcesCodeGetErrors];

export type GetResourceResourcesCodeGetResponses = {
    /**
     * Successfully fetched resource.
     */
    200: ResourceResponseSchema;
};

export type GetResourceResourcesCodeGetResponse = GetResourceResourcesCodeGetResponses[keyof GetResourceResourcesCodeGetResponses];

export type GetAllTasksTasksListGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Minimum level
         *
         * Minimum level.
         */
        min_level?: number;
        /**
         * Maximum level
         *
         * Maximum level.
         */
        max_level?: number;
        /**
         * Skill
         *
         * Skill of tasks.
         */
        skill?: Skill;
        /**
         * Type
         *
         * Type of tasks.
         */
        type?: TaskType;
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/tasks/list';
};

export type GetAllTasksTasksListGetResponses = {
    /**
     * Successfully fetched tasks.
     */
    200: DataPageTaskFullSchema;
};

export type GetAllTasksTasksListGetResponse = GetAllTasksTasksListGetResponses[keyof GetAllTasksTasksListGetResponses];

export type GetTaskTasksListCodeGetData = {
    body?: never;
    path: {
        /**
         * Task code
         *
         * The code of the task.
         */
        code: string;
    };
    query?: never;
    url: '/tasks/list/{code}';
};

export type GetTaskTasksListCodeGetErrors = {
    /**
     * task not found.
     */
    404: ErrorResponseSchema;
};

export type GetTaskTasksListCodeGetError = GetTaskTasksListCodeGetErrors[keyof GetTaskTasksListCodeGetErrors];

export type GetTaskTasksListCodeGetResponses = {
    /**
     * Successfully fetched task.
     */
    200: TaskFullResponseSchema;
};

export type GetTaskTasksListCodeGetResponse = GetTaskTasksListCodeGetResponses[keyof GetTaskTasksListCodeGetResponses];

export type GetAllTasksRewardsTasksRewardsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page
         *
         * Page number
         */
        page?: number;
        /**
         * Size
         *
         * Page size
         */
        size?: number;
    };
    url: '/tasks/rewards';
};

export type GetAllTasksRewardsTasksRewardsGetResponses = {
    /**
     * Successfully fetched tasks rewards.
     */
    200: DataPageDropRateSchema;
};

export type GetAllTasksRewardsTasksRewardsGetResponse = GetAllTasksRewardsTasksRewardsGetResponses[keyof GetAllTasksRewardsTasksRewardsGetResponses];

export type GetTasksRewardTasksRewardsCodeGetData = {
    body?: never;
    path: {
        /**
         * Tasks Reward code
         *
         * The code of the tasks reward.
         */
        code: string;
    };
    query?: never;
    url: '/tasks/rewards/{code}';
};

export type GetTasksRewardTasksRewardsCodeGetErrors = {
    /**
     * tasks reward not found.
     */
    404: ErrorResponseSchema;
};

export type GetTasksRewardTasksRewardsCodeGetError = GetTasksRewardTasksRewardsCodeGetErrors[keyof GetTasksRewardTasksRewardsCodeGetErrors];

export type GetTasksRewardTasksRewardsCodeGetResponses = {
    /**
     * Successfully fetched tasks reward.
     */
    200: RewardResponseSchema;
};

export type GetTasksRewardTasksRewardsCodeGetResponse = GetTasksRewardTasksRewardsCodeGetResponses[keyof GetTasksRewardTasksRewardsCodeGetResponses];

export type FightSimulationSimulationFightSimulationPostData = {
    body: CombatSimulationRequestSchema;
    path?: never;
    query?: never;
    url: '/simulation/fight_simulation';
};

export type FightSimulationSimulationFightSimulationPostErrors = {
    /**
     * Monster not found.
     */
    404: ErrorResponseSchema;
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Access denied, you must be a member to do that.
     */
    451: ErrorResponseSchema;
};

export type FightSimulationSimulationFightSimulationPostError = FightSimulationSimulationFightSimulationPostErrors[keyof FightSimulationSimulationFightSimulationPostErrors];

export type FightSimulationSimulationFightSimulationPostResponses = {
    /**
     * Combat simulation completed successfully.
     */
    200: CombatSimulationResponseSchema;
};

export type FightSimulationSimulationFightSimulationPostResponse = FightSimulationSimulationFightSimulationPostResponses[keyof FightSimulationSimulationFightSimulationPostResponses];

export type GenerateTokenTokenPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/token';
};

export type GenerateTokenTokenPostErrors = {
    /**
     * Request could not be processed due to an invalid payload.
     */
    422: ErrorResponseSchema;
    /**
     * Failed to generate token.
     */
    455: ErrorResponseSchema;
};

export type GenerateTokenTokenPostError = GenerateTokenTokenPostErrors[keyof GenerateTokenTokenPostErrors];

export type GenerateTokenTokenPostResponses = {
    /**
     * Token generated successfully
     */
    200: TokenResponseSchema;
};

export type GenerateTokenTokenPostResponse = GenerateTokenTokenPostResponses[keyof GenerateTokenTokenPostResponses];
