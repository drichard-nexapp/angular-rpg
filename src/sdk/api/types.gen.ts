// This file is auto-generated by @hey-api/openapi-ts

export interface ClientOptions {
  baseUrl: `${string}://${string}` | (string & {})
}

/**
 * AccessSchema
 */
export interface AccessSchema {
  /**
   * Map access type determining movement and accessibility
   */
  type: MapAccessType
  /**
   * Conditions
   *
   * Access conditions for the map
   */
  conditions?: ConditionSchema[]
}

/**
 * AccountAchievementSchema
 */
export interface AccountAchievementSchema {
  /**
   * Name
   *
   * Name of the achievement.
   */
  name: string
  /**
   * Code
   *
   * Code of the achievement.
   */
  code: string
  /**
   * Description
   *
   * Description of the achievement.
   */
  description: string
  /**
   * Points
   *
   * Points of the achievement. Used for the leaderboard.
   */
  points: number
  /**
   * Type of achievement.
   */
  type: AchievementType
  /**
   * Target
   *
   * Target of the achievement.
   */
  target?: string
  /**
   * Total
   *
   * Total to do.
   */
  total: number
  /**
   * Rewards.
   */
  rewards: AchievementRewardsSchema
  /**
   * Current
   *
   * Current progress.
   */
  current: number
  /**
   * Completed At
   *
   * Completed at.
   */
  completed_at?: string
}

/**
 * AccountDetails
 */
export interface AccountDetails {
  /**
   * Username
   *
   * Username.
   */
  username: string
  /**
   * Member
   *
   * Member status.
   */
  member: boolean
  /**
   * Account status.
   */
  status: AccountStatus
  /**
   * Badges
   *
   * Account badges.
   */
  badges?: string[]
  /**
   * Skins
   *
   * Skins owned.
   */
  skins: string[]
  /**
   * Achievements Points
   *
   * Achievement points.
   */
  achievements_points: number
  /**
   * Banned
   *
   * Banned.
   */
  banned: boolean
  /**
   * Ban Reason
   *
   * Ban reason.
   */
  ban_reason?: string
}

/**
 * AccountDetailsSchema
 */
export interface AccountDetailsSchema {
  data: AccountDetails
}

/**
 * AccountLeaderboardSchema
 */
export interface AccountLeaderboardSchema {
  /**
   * Position
   *
   * Position in the leaderboard.
   */
  position: number
  /**
   * Account
   *
   * Account name.
   */
  account: string
  /**
   * Member status.
   */
  status: AccountStatus
  /**
   * Achievements Points
   *
   * Achievements points.
   */
  achievements_points: number
  /**
   * Gold
   *
   * Gold in the account.
   */
  gold: number
}

/**
 * AccountLeaderboardType
 */
export type AccountLeaderboardType = 'achievements_points' | 'gold'

/**
 * AccountStatus
 */
export type AccountStatus = 'standard' | 'founder' | 'gold_founder' | 'vip_founder'

/**
 * AchievementResponseSchema
 */
export interface AchievementResponseSchema {
  data: AchievementSchema
}

/**
 * AchievementRewardsSchema
 */
export interface AchievementRewardsSchema {
  /**
   * Gold
   *
   * Gold rewards.
   */
  gold: number
}

/**
 * AchievementSchema
 */
export interface AchievementSchema {
  /**
   * Name
   *
   * Name of the achievement.
   */
  name: string
  /**
   * Code
   *
   * Code of the achievement.
   */
  code: string
  /**
   * Description
   *
   * Description of the achievement.
   */
  description: string
  /**
   * Points
   *
   * Points of the achievement. Used for the leaderboard.
   */
  points: number
  /**
   * Type of achievement.
   */
  type: AchievementType
  /**
   * Target
   *
   * Target of the achievement.
   */
  target?: string
  /**
   * Total
   *
   * Total to do.
   */
  total: number
  /**
   * Rewards.
   */
  rewards: AchievementRewardsSchema
}

/**
 * AchievementType
 */
export type AchievementType =
  | 'combat_kill'
  | 'combat_drop'
  | 'combat_level'
  | 'gathering'
  | 'crafting'
  | 'recycling'
  | 'task'
  | 'other'
  | 'use'

/**
 * ActionType
 */
export type ActionType =
  | 'movement'
  | 'fight'
  | 'multi_fight'
  | 'crafting'
  | 'gathering'
  | 'buy_ge'
  | 'sell_ge'
  | 'buy_npc'
  | 'sell_npc'
  | 'cancel_ge'
  | 'delete_item'
  | 'deposit_item'
  | 'withdraw_item'
  | 'deposit_gold'
  | 'withdraw_gold'
  | 'equip'
  | 'unequip'
  | 'task'
  | 'recycling'
  | 'rest'
  | 'use'
  | 'buy_bank_expansion'
  | 'give_item'
  | 'give_gold'
  | 'change_skin'
  | 'rename'
  | 'transition'

/**
 * ActiveCharacterSchema
 */
export interface ActiveCharacterSchema {
  /**
   * Name
   *
   * Name of the character.
   */
  name: string
  /**
   * Account
   *
   * Account name.
   */
  account: string
  /**
   * Character skin code.
   */
  skin: CharacterSkin
  /**
   * X
   *
   * Character x coordinate.
   */
  x: number
  /**
   * Y
   *
   * Character y coordinate.
   */
  y: number
  /**
   * Character current layer.
   */
  layer: MapLayer
  /**
   * Map Id
   *
   * Character current map ID.
   */
  map_id: number
}

/**
 * ActiveEventResponseSchema
 */
export interface ActiveEventResponseSchema {
  data: ActiveEventSchema
}

/**
 * ActiveEventSchema
 */
export interface ActiveEventSchema {
  /**
   * Name
   *
   * Name of the event.
   */
  name: string
  /**
   * Code
   *
   * Code of the event.
   */
  code: string
  /**
   * Map of the event.
   */
  map: MapSchema
  /**
   * Previous map skin.
   */
  previous_map: MapSchema
  /**
   * Duration
   *
   * Duration in minutes.
   */
  duration: number
  /**
   * Expiration
   *
   * Expiration datetime.
   */
  expiration: string
  /**
   * Created At
   *
   * Start datetime.
   */
  created_at: string
}

/**
 * AddAccountSchema
 */
export interface AddAccountSchema {
  /**
   * Username
   *
   * Your desired username.
   */
  username: string
  /**
   * Password
   *
   * Your password.
   */
  password: string
  /**
   * Email
   *
   * Your email.
   */
  email: string
}

/**
 * AddCharacterSchema
 */
export interface AddCharacterSchema {
  /**
   * Name
   *
   * Your desired character name. It's unique and all players can see it.
   */
  name: string
  /**
   * Your desired skin. Skins unlocked by default: 'men1', 'men2', 'men3', 'women1', 'women2', 'women3'.
   */
  skin: CharacterSkin
}

/**
 * BadgeConditionSchema
 */
export interface BadgeConditionSchema {
  /**
   * Code
   *
   * Code of the condition.
   */
  code: string
  /**
   * Quantity
   *
   * Quantity of the condition (if any).
   */
  quantity?: number
}

/**
 * BadgeResponseSchema
 */
export interface BadgeResponseSchema {
  data: BadgeSchema
}

/**
 * BadgeSchema
 */
export interface BadgeSchema {
  /**
   * Code
   *
   * Code of the badge. This is the badge's unique identifier (ID).
   */
  code: string
  /**
   * Season
   *
   * Season of the badge.
   */
  season?: number
  /**
   * Description
   *
   * Description of the badge.
   */
  description: string
  /**
   * Conditions
   *
   * Conditions to get the badge.
   */
  conditions: BadgeConditionSchema[]
}

/**
 * BankExtensionSchema
 */
export interface BankExtensionSchema {
  /**
   * Price
   *
   * Price of the bank extension.
   */
  price: number
}

/**
 * BankExtensionTransactionResponseSchema
 */
export interface BankExtensionTransactionResponseSchema {
  data: BankExtensionTransactionSchema
}

/**
 * BankExtensionTransactionSchema
 */
export interface BankExtensionTransactionSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Transaction details.
   */
  transaction: BankExtensionSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * BankGoldTransactionResponseSchema
 */
export interface BankGoldTransactionResponseSchema {
  data: BankGoldTransactionSchema
}

/**
 * BankGoldTransactionSchema
 */
export interface BankGoldTransactionSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Bank details.
   */
  bank: GoldSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * BankItemTransactionResponseSchema
 */
export interface BankItemTransactionResponseSchema {
  data: BankItemTransactionSchema
}

/**
 * BankItemTransactionSchema
 */
export interface BankItemTransactionSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Items
   *
   * Items details.
   */
  items: SimpleItemSchema[]
  /**
   * Bank
   *
   * Items in your banks.
   */
  bank: SimpleItemSchema[]
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * BankResponseSchema
 */
export interface BankResponseSchema {
  data: BankSchema
}

/**
 * BankSchema
 */
export interface BankSchema {
  /**
   * Slots
   *
   * Maximum slots in your bank.
   */
  slots: number
  /**
   * Expansions
   *
   * Bank expansions.
   */
  expansions: number
  /**
   * Next Expansion Cost
   *
   * Next expansion cost.
   */
  next_expansion_cost: number
  /**
   * Gold
   *
   * Quantity of gold in your bank.
   */
  gold: number
}

/**
 * ChangePassword
 */
export interface ChangePassword {
  /**
   * Current Password
   *
   * Your password.
   */
  current_password: string
  /**
   * New Password
   *
   * New password.
   */
  new_password: string
}

/**
 * ChangeSkinCharacterDataSchema
 */
export interface ChangeSkinCharacterDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Skin
   *
   * Craft details.
   */
  skin: string
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * ChangeSkinCharacterSchema
 */
export interface ChangeSkinCharacterSchema {
  /**
   * Your desired skin. Skins unlocked by default: 'men1', 'men2', 'men3', 'women1', 'women2', 'women3'.
   */
  skin: CharacterSkin
}

/**
 * ChangeSkinResponseSchema
 */
export interface ChangeSkinResponseSchema {
  data: ChangeSkinCharacterDataSchema
}

/**
 * CharacterFightDataSchema
 */
export interface CharacterFightDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Character fight details.
   */
  fight: CharacterFightSchema
  /**
   * Characters
   *
   * All characters involved.
   */
  characters: CharacterSchema[]
}

/**
 * CharacterFightResponseSchema
 */
export interface CharacterFightResponseSchema {
  data: CharacterFightDataSchema
}

/**
 * CharacterFightSchema
 */
export interface CharacterFightSchema {
  /**
   * The result of the fight.
   */
  result: FightResult
  /**
   * Turns
   *
   * Numbers of the turns of the combat.
   */
  turns: number
  /**
   * Opponent
   *
   * The code of the monster fought.
   */
  opponent: string
  /**
   * Logs
   *
   * The fight logs.
   */
  logs: string[]
  /**
   * Characters
   *
   * Results for each character.
   */
  characters: CharacterMultiFightResultSchema[]
}

/**
 * CharacterLeaderboardSchema
 */
export interface CharacterLeaderboardSchema {
  /**
   * Position
   *
   * Position in the leaderboard.
   */
  position: number
  /**
   * Name
   *
   * Character name.
   */
  name: string
  /**
   * Account
   *
   * Account name.
   */
  account: string
  /**
   * Member status.
   */
  status: AccountStatus
  /**
   * Skin
   *
   * Character skin code.
   */
  skin: string
  /**
   * Level
   *
   * Combat level.
   */
  level: number
  /**
   * Total Xp
   *
   * Total XP of your character.
   */
  total_xp: number
  /**
   * Mining Level
   *
   * Mining level.
   */
  mining_level: number
  /**
   * Mining Total Xp
   *
   * Mining total xp.
   */
  mining_total_xp: number
  /**
   * Woodcutting Level
   *
   * Woodcutting level.
   */
  woodcutting_level: number
  /**
   * Woodcutting Total Xp
   *
   * Woodcutting total xp.
   */
  woodcutting_total_xp: number
  /**
   * Fishing Level
   *
   * Fishing level.
   */
  fishing_level: number
  /**
   * Fishing Total Xp
   *
   * Fishing total xp.
   */
  fishing_total_xp: number
  /**
   * Weaponcrafting Level
   *
   * Weaponcrafting level.
   */
  weaponcrafting_level: number
  /**
   * Weaponcrafting Total Xp
   *
   * Weaponcrafting total xp.
   */
  weaponcrafting_total_xp: number
  /**
   * Gearcrafting Level
   *
   * Gearcrafting level.
   */
  gearcrafting_level: number
  /**
   * Gearcrafting Total Xp
   *
   * Gearcrafting total xp.
   */
  gearcrafting_total_xp: number
  /**
   * Jewelrycrafting Level
   *
   * Jewelrycrafting level.
   */
  jewelrycrafting_level: number
  /**
   * Jewelrycrafting Total Xp
   *
   * Jewelrycrafting total xp.
   */
  jewelrycrafting_total_xp: number
  /**
   * Cooking Level
   *
   * Cooking level.
   */
  cooking_level: number
  /**
   * Cooking Total Xp
   *
   * Cooking total xp.
   */
  cooking_total_xp: number
  /**
   * Alchemy Level
   *
   * Alchemy level.
   */
  alchemy_level: number
  /**
   * Alchemy Total Xp
   *
   * Alchemy total xp.
   */
  alchemy_total_xp: number
  /**
   * Gold
   *
   * The numbers of gold on this character.
   */
  gold: number
}

/**
 * CharacterLeaderboardType
 */
export type CharacterLeaderboardType =
  | 'combat'
  | 'woodcutting'
  | 'mining'
  | 'fishing'
  | 'weaponcrafting'
  | 'gearcrafting'
  | 'jewelrycrafting'
  | 'cooking'
  | 'alchemy'

/**
 * CharacterMovementDataSchema
 */
export interface CharacterMovementDataSchema {
  /**
   * Cooldown details
   */
  cooldown: CooldownSchema
  /**
   * Destination details.
   */
  destination: MapSchema
  /**
   * Path
   *
   * Path taken from start to destination (list of coordinates)
   */
  path: [number, number][]
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * CharacterMovementResponseSchema
 */
export interface CharacterMovementResponseSchema {
  data: CharacterMovementDataSchema
}

/**
 * CharacterMultiFightResultSchema
 */
export interface CharacterMultiFightResultSchema {
  /**
   * Character Name
   *
   * Name of the character.
   */
  character_name: string
  /**
   * Xp
   *
   * XP gained by this character.
   */
  xp: number
  /**
   * Gold
   *
   * Gold gained by this character.
   */
  gold: number
  /**
   * Drops
   *
   * Items dropped for this character.
   */
  drops: DropSchema[]
  /**
   * Final Hp
   *
   * Character's HP at the end of combat.
   */
  final_hp: number
}

/**
 * CharacterResponseSchema
 */
export interface CharacterResponseSchema {
  data: CharacterSchema
}

/**
 * CharacterRestDataSchema
 */
export interface CharacterRestDataSchema {
  /**
   * Cooldown details
   */
  cooldown: CooldownSchema
  /**
   * Hp Restored
   *
   * The amount of HP restored.
   */
  hp_restored: number
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * CharacterRestResponseSchema
 */
export interface CharacterRestResponseSchema {
  data: CharacterRestDataSchema
}

/**
 * CharacterSchema
 */
export interface CharacterSchema {
  /**
   * Name
   *
   * Name of the character.
   */
  name: string
  /**
   * Account
   *
   * Account name.
   */
  account: string
  /**
   * Character skin code.
   */
  skin: CharacterSkin
  /**
   * Level
   *
   * Combat level.
   */
  level: number
  /**
   * Xp
   *
   * The current xp level of the combat level.
   */
  xp: number
  /**
   * Max Xp
   *
   * XP required to level up the character.
   */
  max_xp: number
  /**
   * Gold
   *
   * The numbers of gold on this character.
   */
  gold: number
  /**
   * Speed
   *
   * *Not available, on the roadmap. Character movement speed.
   */
  speed: number
  /**
   * Mining Level
   *
   * Mining level.
   */
  mining_level: number
  /**
   * Mining Xp
   *
   * The current xp level of the Mining skill.
   */
  mining_xp: number
  /**
   * Mining Max Xp
   *
   * Mining XP required to level up the skill.
   */
  mining_max_xp: number
  /**
   * Woodcutting Level
   *
   * Woodcutting level.
   */
  woodcutting_level: number
  /**
   * Woodcutting Xp
   *
   * The current xp level of the Woodcutting skill.
   */
  woodcutting_xp: number
  /**
   * Woodcutting Max Xp
   *
   * Woodcutting XP required to level up the skill.
   */
  woodcutting_max_xp: number
  /**
   * Fishing Level
   *
   * Fishing level.
   */
  fishing_level: number
  /**
   * Fishing Xp
   *
   * The current xp level of the Fishing skill.
   */
  fishing_xp: number
  /**
   * Fishing Max Xp
   *
   * Fishing XP required to level up the skill.
   */
  fishing_max_xp: number
  /**
   * Weaponcrafting Level
   *
   * Weaponcrafting level.
   */
  weaponcrafting_level: number
  /**
   * Weaponcrafting Xp
   *
   * The current xp level of the Weaponcrafting skill.
   */
  weaponcrafting_xp: number
  /**
   * Weaponcrafting Max Xp
   *
   * Weaponcrafting XP required to level up the skill.
   */
  weaponcrafting_max_xp: number
  /**
   * Gearcrafting Level
   *
   * Gearcrafting level.
   */
  gearcrafting_level: number
  /**
   * Gearcrafting Xp
   *
   * The current xp level of the Gearcrafting skill.
   */
  gearcrafting_xp: number
  /**
   * Gearcrafting Max Xp
   *
   * Gearcrafting XP required to level up the skill.
   */
  gearcrafting_max_xp: number
  /**
   * Jewelrycrafting Level
   *
   * Jewelrycrafting level.
   */
  jewelrycrafting_level: number
  /**
   * Jewelrycrafting Xp
   *
   * The current xp level of the Jewelrycrafting skill.
   */
  jewelrycrafting_xp: number
  /**
   * Jewelrycrafting Max Xp
   *
   * Jewelrycrafting XP required to level up the skill.
   */
  jewelrycrafting_max_xp: number
  /**
   * Cooking Level
   *
   * The current xp level of the Cooking skill.
   */
  cooking_level: number
  /**
   * Cooking Xp
   *
   * Cooking XP.
   */
  cooking_xp: number
  /**
   * Cooking Max Xp
   *
   * Cooking XP required to level up the skill.
   */
  cooking_max_xp: number
  /**
   * Alchemy Level
   *
   * Alchemy level.
   */
  alchemy_level: number
  /**
   * Alchemy Xp
   *
   * Alchemy XP.
   */
  alchemy_xp: number
  /**
   * Alchemy Max Xp
   *
   * Alchemy XP required to level up the skill.
   */
  alchemy_max_xp: number
  /**
   * Hp
   *
   * Character actual HP.
   */
  hp: number
  /**
   * Max Hp
   *
   * Character max HP.
   */
  max_hp: number
  /**
   * Haste
   *
   * *Increase speed attack (reduce fight cooldown)
   */
  haste: number
  /**
   * Critical Strike
   *
   * % Critical strike. Critical strikes adds 50% extra damage to an attack (1.5x).
   */
  critical_strike: number
  /**
   * Wisdom
   *
   * Wisdom increases the amount of XP gained from fights and skills (1% extra per 10 wisdom).
   */
  wisdom: number
  /**
   * Prospecting
   *
   * Prospecting increases the chances of getting drops from fights and skills (1% extra per 10 PP).
   */
  prospecting: number
  /**
   * Initiative
   *
   * Initiative determines turn order in combat. Higher initiative goes first.
   */
  initiative: number
  /**
   * Threat
   *
   * Threat level affects monster targeting in multi-character combat.
   */
  threat: number
  /**
   * Attack Fire
   *
   * Fire attack.
   */
  attack_fire: number
  /**
   * Attack Earth
   *
   * Earth attack.
   */
  attack_earth: number
  /**
   * Attack Water
   *
   * Water attack.
   */
  attack_water: number
  /**
   * Attack Air
   *
   * Air attack.
   */
  attack_air: number
  /**
   * Dmg
   *
   * % Damage. Damage increases your attack in all elements.
   */
  dmg: number
  /**
   * Dmg Fire
   *
   * % Fire damage. Damage increases your fire attack.
   */
  dmg_fire: number
  /**
   * Dmg Earth
   *
   * % Earth damage. Damage increases your earth attack.
   */
  dmg_earth: number
  /**
   * Dmg Water
   *
   * % Water damage. Damage increases your water attack.
   */
  dmg_water: number
  /**
   * Dmg Air
   *
   * % Air damage. Damage increases your air attack.
   */
  dmg_air: number
  /**
   * Res Fire
   *
   * % Fire resistance. Reduces fire attack.
   */
  res_fire: number
  /**
   * Res Earth
   *
   * % Earth resistance. Reduces earth attack.
   */
  res_earth: number
  /**
   * Res Water
   *
   * % Water resistance. Reduces water attack.
   */
  res_water: number
  /**
   * Res Air
   *
   * % Air resistance. Reduces air attack.
   */
  res_air: number
  /**
   * Effects
   *
   * List of active effects on the character.
   */
  effects?: StorageEffectSchema[]
  /**
   * X
   *
   * Character x coordinate.
   */
  x: number
  /**
   * Y
   *
   * Character y coordinate.
   */
  y: number
  /**
   * Character current layer.
   */
  layer: MapLayer
  /**
   * Map Id
   *
   * Character current map ID.
   */
  map_id: number
  /**
   * Cooldown
   *
   * Cooldown in seconds.
   */
  cooldown: number
  /**
   * Cooldown Expiration
   *
   * Datetime Cooldown expiration.
   */
  cooldown_expiration?: string
  /**
   * Weapon Slot
   *
   * Weapon slot.
   */
  weapon_slot: string
  /**
   * Rune Slot
   *
   * Rune slot.
   */
  rune_slot: string
  /**
   * Shield Slot
   *
   * Shield slot.
   */
  shield_slot: string
  /**
   * Helmet Slot
   *
   * Helmet slot.
   */
  helmet_slot: string
  /**
   * Body Armor Slot
   *
   * Body armor slot.
   */
  body_armor_slot: string
  /**
   * Leg Armor Slot
   *
   * Leg armor slot.
   */
  leg_armor_slot: string
  /**
   * Boots Slot
   *
   * Boots slot.
   */
  boots_slot: string
  /**
   * Ring1 Slot
   *
   * Ring 1 slot.
   */
  ring1_slot: string
  /**
   * Ring2 Slot
   *
   * Ring 2 slot.
   */
  ring2_slot: string
  /**
   * Amulet Slot
   *
   * Amulet slot.
   */
  amulet_slot: string
  /**
   * Artifact1 Slot
   *
   * Artifact 1 slot.
   */
  artifact1_slot: string
  /**
   * Artifact2 Slot
   *
   * Artifact 2 slot.
   */
  artifact2_slot: string
  /**
   * Artifact3 Slot
   *
   * Artifact 3 slot.
   */
  artifact3_slot: string
  /**
   * Utility1 Slot
   *
   * Utility 1 slot.
   */
  utility1_slot: string
  /**
   * Utility1 Slot Quantity
   *
   * Utility 1 quantity.
   */
  utility1_slot_quantity: number
  /**
   * Utility2 Slot
   *
   * Utility 2 slot.
   */
  utility2_slot: string
  /**
   * Utility2 Slot Quantity
   *
   * Utility 2 quantity.
   */
  utility2_slot_quantity: number
  /**
   * Bag Slot
   *
   * Bag slot.
   */
  bag_slot: string
  /**
   * Task
   *
   * Task in progress.
   */
  task: string
  /**
   * Task Type
   *
   * Task type.
   */
  task_type: string
  /**
   * Task Progress
   *
   * Task progression.
   */
  task_progress: number
  /**
   * Task Total
   *
   * Task total objective.
   */
  task_total: number
  /**
   * Inventory Max Items
   *
   * Inventory max items.
   */
  inventory_max_items: number
  /**
   * Inventory
   *
   * List of inventory slots.
   */
  inventory?: InventorySlot[]
}

/**
 * CharacterSkin
 */
export type CharacterSkin =
  | 'men1'
  | 'men2'
  | 'men3'
  | 'women1'
  | 'women2'
  | 'women3'
  | 'corrupted1'
  | 'zombie1'
  | 'marauder1'

/**
 * CharacterTransitionDataSchema
 */
export interface CharacterTransitionDataSchema {
  /**
   * Cooldown details
   */
  cooldown: CooldownSchema
  /**
   * Destination map details.
   */
  destination: MapSchema
  /**
   * Transition details.
   */
  transition: TransitionSchema
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * CharacterTransitionResponseSchema
 */
export interface CharacterTransitionResponseSchema {
  data: CharacterTransitionDataSchema
}

/**
 * CharactersListSchema
 */
export interface CharactersListSchema {
  /**
   * Data
   *
   * List of your characters.
   */
  data: CharacterSchema[]
}

/**
 * CombatResultSchema
 */
export interface CombatResultSchema {
  /**
   * Result
   *
   * Combat result: 'win' or 'loss'.
   */
  result: string
  /**
   * Turns
   *
   * Number of turns the combat lasted.
   */
  turns: number
  /**
   * Logs
   *
   * Combat logs.
   */
  logs: string[]
  /**
   * Character Results
   *
   * Character results from combat.
   */
  character_results: Record<string, unknown>[]
}

/**
 * CombatSimulationDataSchema
 */
export interface CombatSimulationDataSchema {
  /**
   * Results
   *
   * Results from each combat iteration.
   */
  results: CombatResultSchema[]
  /**
   * Wins
   *
   * Total number of victories.
   */
  wins: number
  /**
   * Losses
   *
   * Total number of defeats.
   */
  losses: number
  /**
   * Winrate
   *
   * Win rate percentage (0-100).
   */
  winrate: number
}

/**
 * CombatSimulationRequestSchema
 */
export interface CombatSimulationRequestSchema {
  /**
   * Characters
   *
   * List of fake characters (1-3).
   */
  characters: FakeCharacterSchema[]
  /**
   * Monster
   *
   * Monster code to fight against.
   */
  monster: string
  /**
   * Iterations
   *
   * Number of combat iterations to simulate.
   */
  iterations: number
}

/**
 * CombatSimulationResponseSchema
 */
export interface CombatSimulationResponseSchema {
  /**
   * Combat simulation results.
   */
  data: CombatSimulationDataSchema
}

/**
 * ConditionOperator
 */
export type ConditionOperator = 'eq' | 'ne' | 'gt' | 'lt' | 'cost' | 'has_item' | 'achievement_unlocked'

/**
 * ConditionSchema
 */
export interface ConditionSchema {
  /**
   * Code
   *
   * Condition code.
   */
  code: string
  /**
   * Condition operator.
   */
  operator: ConditionOperator
  /**
   * Value
   *
   * Condition value.
   */
  value: number
}

/**
 * CooldownSchema
 */
export interface CooldownSchema {
  /**
   * Total Seconds
   *
   * The total seconds of the cooldown.
   */
  total_seconds: number
  /**
   * Remaining Seconds
   *
   * The remaining seconds of the cooldown.
   */
  remaining_seconds: number
  /**
   * Started At
   *
   * The start of the cooldown.
   */
  started_at: string
  /**
   * Expiration
   *
   * The expiration of the cooldown.
   */
  expiration: string
  /**
   * The reason of the cooldown.
   */
  reason: ActionType
}

/**
 * CraftSchema
 */
export interface CraftSchema {
  /**
   * Skill code
   *
   * Skill required to craft the item.
   */
  skill?: CraftSkill
  /**
   * Level
   *
   * The skill level required to craft the item.
   */
  level?: number
  /**
   * Items
   *
   * List of items required to craft the item.
   */
  items?: SimpleItemSchema[]
  /**
   * Quantity
   *
   * Quantity of items crafted.
   */
  quantity?: number
}

/**
 * CraftSkill
 */
export type CraftSkill =
  | 'weaponcrafting'
  | 'gearcrafting'
  | 'jewelrycrafting'
  | 'cooking'
  | 'woodcutting'
  | 'mining'
  | 'alchemy'

/**
 * CraftingSchema
 */
export interface CraftingSchema {
  /**
   * Craft code
   *
   * Craft code.
   */
  code: string
  /**
   * Quantity
   *
   * Quantity of items to craft.
   */
  quantity?: number
}

/**
 * DataPage[AccountAchievementSchema]
 */
export interface DataPageAccountAchievementSchema {
  /**
   * Data
   */
  data: AccountAchievementSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[AccountLeaderboardSchema]
 */
export interface DataPageAccountLeaderboardSchema {
  /**
   * Data
   */
  data: AccountLeaderboardSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[AchievementSchema]
 */
export interface DataPageAchievementSchema {
  /**
   * Data
   */
  data: AchievementSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[ActiveCharacterSchema]
 */
export interface DataPageActiveCharacterSchema {
  /**
   * Data
   */
  data: ActiveCharacterSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[ActiveEventSchema]
 */
export interface DataPageActiveEventSchema {
  /**
   * Data
   */
  data: ActiveEventSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[BadgeSchema]
 */
export interface DataPageBadgeSchema {
  /**
   * Data
   */
  data: BadgeSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[CharacterLeaderboardSchema]
 */
export interface DataPageCharacterLeaderboardSchema {
  /**
   * Data
   */
  data: CharacterLeaderboardSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[DropRateSchema]
 */
export interface DataPageDropRateSchema {
  /**
   * Data
   */
  data: DropRateSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[EffectSchema]
 */
export interface DataPageEffectSchema {
  /**
   * Data
   */
  data: EffectSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[EventSchema]
 */
export interface DataPageEventSchema {
  /**
   * Data
   */
  data: EventSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[GEOrderSchema]
 */
export interface DataPageGeOrderSchema {
  /**
   * Data
   */
  data: GeOrderSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[GeOrderHistorySchema]
 */
export interface DataPageGeOrderHistorySchema {
  /**
   * Data
   */
  data: GeOrderHistorySchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[ItemSchema]
 */
export interface DataPageItemSchema {
  /**
   * Data
   */
  data: ItemSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[LogSchema]
 */
export interface DataPageLogSchema {
  /**
   * Data
   */
  data: LogSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[MapSchema]
 */
export interface DataPageMapSchema {
  /**
   * Data
   */
  data: MapSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[MonsterSchema]
 */
export interface DataPageMonsterSchema {
  /**
   * Data
   */
  data: MonsterSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[NPCItem]
 */
export interface DataPageNpcItem {
  /**
   * Data
   */
  data: NpcItem[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[NPCSchema]
 */
export interface DataPageNpcSchema {
  /**
   * Data
   */
  data: NpcSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[ResourceSchema]
 */
export interface DataPageResourceSchema {
  /**
   * Data
   */
  data: ResourceSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[SimpleItemSchema]
 */
export interface DataPageSimpleItemSchema {
  /**
   * Data
   */
  data: SimpleItemSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DataPage[TaskFullSchema]
 */
export interface DataPageTaskFullSchema {
  /**
   * Data
   */
  data: TaskFullSchema[]
  /**
   * Total
   */
  total?: number
  /**
   * Page
   */
  page?: number
  /**
   * Size
   */
  size?: number
  /**
   * Pages
   */
  pages?: number
}

/**
 * DeleteCharacterSchema
 */
export interface DeleteCharacterSchema {
  /**
   * Name
   *
   * Character name.
   */
  name: string
}

/**
 * DeleteItemResponseSchema
 */
export interface DeleteItemResponseSchema {
  data: DeleteItemSchema
}

/**
 * DeleteItemSchema
 */
export interface DeleteItemSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Item details.
   */
  item: SimpleItemSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * DepositWithdrawGoldSchema
 */
export interface DepositWithdrawGoldSchema {
  /**
   * Quantity
   *
   * Quantity of gold.
   */
  quantity: number
}

/**
 * DestinationSchema
 */
export interface DestinationSchema {
  /**
   * X
   *
   * The x coordinate of the destination.
   */
  x?: number
  /**
   * Y
   *
   * The y coordinate of the destination.
   */
  y?: number
  /**
   * Map Id
   *
   * The map ID of the destination.
   */
  map_id?: number
}

/**
 * DropRateSchema
 */
export interface DropRateSchema {
  /**
   * Item code
   *
   * Item code.
   */
  code: string
  /**
   * Rate
   *
   * Chance rate. (1/rate)
   */
  rate: number
  /**
   * Min Quantity
   *
   * Minimum quantity.
   */
  min_quantity: number
  /**
   * Max Quantity
   *
   * Maximum quantity.
   */
  max_quantity: number
}

/**
 * DropSchema
 */
export interface DropSchema {
  /**
   * Code
   *
   * The code of the item.
   */
  code: string
  /**
   * Quantity
   *
   * The quantity of the item.
   */
  quantity: number
}

/**
 * EffectResponseSchema
 */
export interface EffectResponseSchema {
  data: EffectSchema
}

/**
 * EffectSchema
 */
export interface EffectSchema {
  /**
   * Name
   *
   * Name of the effect.
   */
  name: string
  /**
   * Code
   *
   * The code of the effect. This is the effect's unique identifier (ID).
   */
  code: string
  /**
   * Description
   *
   * Description of the effect. This is a brief description of the effect.
   */
  description: string
  /**
   * Type of the effect.
   */
  type: EffectType
  /**
   * Subtype of the effect.
   */
  subtype: EffectSubtype
}

/**
 * EffectSubtype
 */
export type EffectSubtype =
  | 'stat'
  | 'other'
  | 'heal'
  | 'buff'
  | 'debuff'
  | 'special'
  | 'gathering'
  | 'teleport'
  | 'gold'

/**
 * EffectType
 */
export type EffectType = 'equipment' | 'consumable' | 'combat'

/**
 * EquipRequestSchema
 */
export interface EquipRequestSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Item slot.
   */
  slot: ItemSlot
  /**
   * Item details.
   */
  item: ItemSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * EquipSchema
 */
export interface EquipSchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Item slot.
   */
  slot: ItemSlot
  /**
   * Quantity
   *
   * Item quantity. Applicable to utilities only.
   */
  quantity?: number
}

/**
 * EquipmentResponseSchema
 */
export interface EquipmentResponseSchema {
  data: EquipRequestSchema
}

/**
 * EventContentSchema
 */
export interface EventContentSchema {
  /**
   * Type of the event.
   */
  type: MapContentType
  /**
   * Code
   *
   * Code content.
   */
  code: string
}

/**
 * EventMapSchema
 */
export interface EventMapSchema {
  /**
   * Map Id
   *
   * ID of the map.
   */
  map_id: number
  /**
   * X
   *
   * Position X of the map.
   */
  x: number
  /**
   * Y
   *
   * Position Y of the map.
   */
  y: number
  /**
   * Layer
   *
   * Layer of the map.
   */
  layer: string
  /**
   * Skin
   *
   * Map skin of the map
   */
  skin: string
}

/**
 * EventSchema
 */
export interface EventSchema {
  /**
   * Name
   *
   * Name of the event.
   */
  name: string
  /**
   * Code
   *
   * Code of the event.
   */
  code: string
  /**
   * Content of the event.
   */
  content: EventContentSchema
  /**
   * Maps
   *
   * Map list of the event.
   */
  maps: EventMapSchema[]
  /**
   * Duration
   *
   * Duration in minutes.
   */
  duration: number
  /**
   * Rate
   *
   * Rate spawn of the event. (1/rate every minute)
   */
  rate: number
}

/**
 * FakeCharacterSchema
 */
export interface FakeCharacterSchema {
  /**
   * Level
   *
   * Character level.
   */
  level: number
  /**
   * Weapon Slot
   *
   * Weapon slot item code.
   */
  weapon_slot?: string
  /**
   * Rune Slot
   *
   * Rune slot item code.
   */
  rune_slot?: string
  /**
   * Shield Slot
   *
   * Shield slot item code.
   */
  shield_slot?: string
  /**
   * Helmet Slot
   *
   * Helmet slot item code.
   */
  helmet_slot?: string
  /**
   * Body Armor Slot
   *
   * Body armor slot item code.
   */
  body_armor_slot?: string
  /**
   * Leg Armor Slot
   *
   * Leg armor slot item code.
   */
  leg_armor_slot?: string
  /**
   * Boots Slot
   *
   * Boots slot item code.
   */
  boots_slot?: string
  /**
   * Ring1 Slot
   *
   * Ring 1 slot item code.
   */
  ring1_slot?: string
  /**
   * Ring2 Slot
   *
   * Ring 2 slot item code.
   */
  ring2_slot?: string
  /**
   * Amulet Slot
   *
   * Amulet slot item code.
   */
  amulet_slot?: string
  /**
   * Artifact1 Slot
   *
   * Artifact 1 slot item code.
   */
  artifact1_slot?: string
  /**
   * Artifact2 Slot
   *
   * Artifact 2 slot item code.
   */
  artifact2_slot?: string
  /**
   * Artifact3 Slot
   *
   * Artifact 3 slot item code.
   */
  artifact3_slot?: string
  /**
   * Utility1 Slot
   *
   * Utility 1 slot item code.
   */
  utility1_slot?: string
  /**
   * Utility1 Slot Quantity
   *
   * Utility 1 quantity.
   */
  utility1_slot_quantity?: number
  /**
   * Utility2 Slot
   *
   * Utility 2 slot item code.
   */
  utility2_slot?: string
  /**
   * Utility2 Slot Quantity
   *
   * Utility 2 quantity.
   */
  utility2_slot_quantity?: number
}

/**
 * FightRequestSchema
 */
export interface FightRequestSchema {
  /**
   * Participants
   *
   * Optional list of additional character names to include in the fight (max 2 additional characters).
   */
  participants?: string[]
}

/**
 * FightResult
 */
export type FightResult = 'win' | 'loss'

/**
 * GEBuyOrderSchema
 */
export interface GeBuyOrderSchema {
  /**
   * Id
   *
   * Order id.
   */
  id: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
}

/**
 * GECancelOrderSchema
 */
export interface GeCancelOrderSchema {
  /**
   * Id
   *
   * Order id.
   */
  id: string
}

/**
 * GECreateOrderTransactionResponseSchema
 */
export interface GeCreateOrderTransactionResponseSchema {
  data: GeOrderTransactionSchema
}

/**
 * GEOrderCreatedSchema
 */
export interface GeOrderCreatedSchema {
  /**
   * Id
   *
   * Order id.
   */
  id: string
  /**
   * Created At
   *
   * Order created at.
   */
  created_at: string
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Price
   *
   * Item price per unit.
   */
  price: number
  /**
   * Total Price
   *
   * Total price.
   */
  total_price: number
  /**
   * Tax
   *
   * Listing tax (3%, minimum 1)
   */
  tax: number
}

/**
 * GEOrderCreationrSchema
 */
export interface GeOrderCreationrSchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Price
   *
   * Item price per unit.
   */
  price: number
}

/**
 * GEOrderResponseSchema
 */
export interface GeOrderResponseSchema {
  data: GeOrderSchema
}

/**
 * GEOrderSchema
 */
export interface GeOrderSchema {
  /**
   * Id
   *
   * Order id.
   */
  id: string
  /**
   * Seller
   *
   * Seller account name.
   */
  seller: string
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Price
   *
   * Item price per unit.
   */
  price: number
  /**
   * Created At
   *
   * Order created at.
   */
  created_at: string
}

/**
 * GEOrderTransactionSchema
 */
export interface GeOrderTransactionSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Order details.
   */
  order: GeOrderCreatedSchema
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * GETransactionListSchema
 */
export interface GeTransactionListSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Transaction details.
   */
  order: GeTransactionSchema
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * GETransactionResponseSchema
 */
export interface GeTransactionResponseSchema {
  data: GeTransactionListSchema
}

/**
 * GETransactionSchema
 */
export interface GeTransactionSchema {
  /**
   * Id
   *
   * Order id.
   */
  id: string
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Price
   *
   * Item price.
   */
  price: number
  /**
   * Total Price
   *
   * Total price of the transaction.
   */
  total_price: number
}

/**
 * GatheringSkill
 */
export type GatheringSkill = 'mining' | 'woodcutting' | 'fishing' | 'alchemy'

/**
 * GeOrderHistorySchema
 */
export interface GeOrderHistorySchema {
  /**
   * Order Id
   *
   * Order id.
   */
  order_id: string
  /**
   * Seller
   *
   * Seller account name.
   */
  seller: string
  /**
   * Buyer
   *
   * Buyer account name.
   */
  buyer: string
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Price
   *
   * Item price per unit.
   */
  price: number
  /**
   * Sold At
   *
   * Sale datetime.
   */
  sold_at: string
}

/**
 * GiveGoldDataSchema
 */
export interface GiveGoldDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Quantity
   *
   * Quantity of gold given.
   */
  quantity: number
  /**
   * Character details of the receiving character.
   */
  receiver_character: CharacterSchema
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * GiveGoldResponseSchema
 */
export interface GiveGoldResponseSchema {
  data: GiveGoldDataSchema
}

/**
 * GiveGoldSchema
 */
export interface GiveGoldSchema {
  /**
   * Quantity
   *
   * Gold quantity.
   */
  quantity: number
  /**
   * Character
   *
   * Character name. The name of the character who will receive the gold.
   */
  character: string
}

/**
 * GiveItemDataSchema
 */
export interface GiveItemDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Items
   *
   * Items given.
   */
  items: SimpleItemSchema[]
  /**
   * Character details of the receiving character.
   */
  receiver_character: CharacterSchema
  /**
   * Character details of the sending character.
   */
  character: CharacterSchema
}

/**
 * GiveItemResponseSchema
 */
export interface GiveItemResponseSchema {
  data: GiveItemDataSchema
}

/**
 * GiveItemsSchema
 */
export interface GiveItemsSchema {
  /**
   * Items
   *
   * List of items to give
   */
  items: SimpleItemSchema[]
  /**
   * Character
   *
   * Character name. The name of the character who will receive the items.
   */
  character: string
}

/**
 * GoldSchema
 */
export interface GoldSchema {
  /**
   * Quantity
   *
   * Quantity of gold.
   */
  quantity: number
}

/**
 * HTTPValidationError
 */
export interface HttpValidationError {
  /**
   * Detail
   */
  detail?: ValidationError[]
}

/**
 * InteractionSchema
 */
export interface InteractionSchema {
  /**
   * Content of the map.
   */
  content?: MapContentSchema
  /**
   * Transition to another map.
   */
  transition?: TransitionSchema
}

/**
 * InventorySlot
 */
export interface InventorySlot {
  /**
   * Slot
   *
   * Inventory slot identifier.
   */
  slot: number
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Quantity in the slot.
   */
  quantity: number
}

/**
 * ItemResponseSchema
 */
export interface ItemResponseSchema {
  data: ItemSchema
}

/**
 * ItemSchema
 */
export interface ItemSchema {
  /**
   * Name
   *
   * Item name.
   */
  name: string
  /**
   * Code
   *
   * Item code. This is the item's unique identifier (ID).
   */
  code: string
  /**
   * Level
   *
   * Item level.
   */
  level: number
  /**
   * Type
   *
   * Item type.
   */
  type: string
  /**
   * Subtype
   *
   * Item subtype.
   */
  subtype: string
  /**
   * Description
   *
   * Item description.
   */
  description: string
  /**
   * Conditions
   *
   * Item conditions. If applicable. Conditions for using or equipping the item.
   */
  conditions?: ConditionSchema[]
  /**
   * Effects
   *
   * List of object effects. For equipment, it will include item stats.
   */
  effects?: SimpleEffectSchema[]
  /**
   * Craft information. If applicable.
   */
  craft?: CraftSchema
  /**
   * Tradeable
   *
   * Item tradeable status. A non-tradeable item cannot be exchanged or sold.
   */
  tradeable: boolean
}

/**
 * ItemSlot
 */
export type ItemSlot =
  | 'weapon'
  | 'shield'
  | 'helmet'
  | 'body_armor'
  | 'leg_armor'
  | 'boots'
  | 'ring1'
  | 'ring2'
  | 'amulet'
  | 'artifact1'
  | 'artifact2'
  | 'artifact3'
  | 'utility1'
  | 'utility2'
  | 'bag'
  | 'rune'

/**
 * ItemType
 */
export type ItemType =
  | 'utility'
  | 'body_armor'
  | 'weapon'
  | 'resource'
  | 'leg_armor'
  | 'helmet'
  | 'boots'
  | 'shield'
  | 'amulet'
  | 'ring'
  | 'artifact'
  | 'currency'
  | 'consumable'
  | 'rune'
  | 'bag'

/**
 * LogSchema
 */
export interface LogSchema {
  /**
   * Character
   *
   * Character name.
   */
  character: string
  /**
   * Account
   *
   * Account character.
   */
  account: string
  /**
   * Type of action.
   */
  type: LogType
  /**
   * Description
   *
   * Description of action.
   */
  description: string
  /**
   * Content
   *
   * Content of action.
   */
  content: unknown
  /**
   * Cooldown
   *
   * Cooldown in seconds.
   */
  cooldown: number
  /**
   * Cooldown Expiration
   *
   * Datetime of cooldown expiration.
   */
  cooldown_expiration?: string
  /**
   * Created At
   *
   * Datetime of creation.
   */
  created_at: string
}

/**
 * LogType
 */
export type LogType =
  | 'spawn'
  | 'movement'
  | 'fight'
  | 'multi_fight'
  | 'crafting'
  | 'gathering'
  | 'buy_ge'
  | 'sell_ge'
  | 'buy_npc'
  | 'sell_npc'
  | 'cancel_ge'
  | 'delete_item'
  | 'deposit_item'
  | 'withdraw_item'
  | 'deposit_gold'
  | 'withdraw_gold'
  | 'equip'
  | 'unequip'
  | 'new_task'
  | 'task_exchange'
  | 'task_cancelled'
  | 'task_completed'
  | 'task_trade'
  | 'recycling'
  | 'rest'
  | 'use'
  | 'buy_bank_expansion'
  | 'achievement'
  | 'give_item'
  | 'give_gold'
  | 'receive_item'
  | 'receive_gold'
  | 'change_skin'
  | 'rename'
  | 'transition'

/**
 * MapAccessType
 */
export type MapAccessType = 'standard' | 'teleportation' | 'conditional' | 'blocked'

/**
 * MapContentSchema
 */
export interface MapContentSchema {
  /**
   * Type of the content.
   */
  type: MapContentType
  /**
   * Code
   *
   * Code of the content.
   */
  code: string
}

/**
 * MapContentType
 */
export type MapContentType = 'monster' | 'resource' | 'workshop' | 'bank' | 'grand_exchange' | 'tasks_master' | 'npc'

/**
 * MapLayer
 */
export type MapLayer = 'interior' | 'overworld' | 'underground'

/**
 * MapResponseSchema
 */
export interface MapResponseSchema {
  data: MapSchema
}

/**
 * MapSchema
 */
export interface MapSchema {
  /**
   * Map Id
   *
   * ID of the map.
   */
  map_id: number
  /**
   * Name
   *
   * Name of the map.
   */
  name: string
  /**
   * Skin
   *
   * Skin of the map.
   */
  skin: string
  /**
   * X
   *
   * Position X of the map.
   */
  x: number
  /**
   * Y
   *
   * Position Y of the map.
   */
  y: number
  /**
   * Layer of the map.
   */
  layer: MapLayer
  /**
   * Access information for the map
   */
  access: AccessSchema
  /**
   * Interactions available on this map.
   */
  interactions: InteractionSchema
}

/**
 * MonsterResponseSchema
 */
export interface MonsterResponseSchema {
  data: MonsterSchema
}

/**
 * MonsterSchema
 */
export interface MonsterSchema {
  /**
   * Name
   *
   * Name of the monster.
   */
  name: string
  /**
   * Code
   *
   * The code of the monster. This is the monster's unique identifier (ID).
   */
  code: string
  /**
   * Level
   *
   * Monster level.
   */
  level: number
  /**
   * Monster type.
   */
  type: MonsterType
  /**
   * Hp
   *
   * Monster hit points.
   */
  hp: number
  /**
   * Attack Fire
   *
   * Monster fire attack.
   */
  attack_fire: number
  /**
   * Attack Earth
   *
   * Monster earth attack.
   */
  attack_earth: number
  /**
   * Attack Water
   *
   * Monster water attack.
   */
  attack_water: number
  /**
   * Attack Air
   *
   * Monster air attack.
   */
  attack_air: number
  /**
   * Res Fire
   *
   * Monster % fire resistance.
   */
  res_fire: number
  /**
   * Res Earth
   *
   * Monster % earth resistance.
   */
  res_earth: number
  /**
   * Res Water
   *
   * Monster % water resistance.
   */
  res_water: number
  /**
   * Res Air
   *
   * Monster % air resistance.
   */
  res_air: number
  /**
   * Critical Strike
   *
   * Monster % critical strike.
   */
  critical_strike: number
  /**
   * Initiative
   *
   * Monster initiative for turn order.
   */
  initiative: number
  /**
   * Effects
   *
   * List of effects.
   */
  effects?: SimpleEffectSchema[]
  /**
   * Min Gold
   *
   * Monster minimum gold drop.
   */
  min_gold: number
  /**
   * Max Gold
   *
   * Monster maximum gold drop.
   */
  max_gold: number
  /**
   * Drops
   *
   * Monster drops. This is a list of items that the monster drops after killing the monster.
   */
  drops: DropRateSchema[]
}

/**
 * MonsterType
 */
export type MonsterType = 'normal' | 'elite' | 'boss'

/**
 * MyAccountDetails
 */
export interface MyAccountDetails {
  /**
   * Username
   *
   * Username.
   */
  username: string
  /**
   * Email
   *
   * Email.
   */
  email: string
  /**
   * Member
   *
   * Member status.
   */
  member: boolean
  /**
   * Member Expiration
   *
   * Member expiration date.
   */
  member_expiration?: string
  /**
   * Account status.
   */
  status: AccountStatus
  /**
   * Badges
   *
   * Account badges.
   */
  badges?: string[]
  /**
   * Skins
   *
   * Skins owned.
   */
  skins: string[]
  /**
   * Gems
   *
   * Gems.
   */
  gems: number
  /**
   * Event Token
   *
   * Event tokens for spawning events.
   */
  event_token: number
  /**
   * Achievements Points
   *
   * Achievement points.
   */
  achievements_points: number
  /**
   * Banned
   *
   * Banned.
   */
  banned: boolean
  /**
   * Ban Reason
   *
   * Ban reason.
   */
  ban_reason?: string
}

/**
 * MyAccountDetailsSchema
 */
export interface MyAccountDetailsSchema {
  data: MyAccountDetails
}

/**
 * MyCharactersListSchema
 */
export interface MyCharactersListSchema {
  /**
   * Data
   *
   * List of your characters.
   */
  data: CharacterSchema[]
}

/**
 * NPCItem
 */
export interface NpcItem {
  /**
   * Code
   *
   * The code of the NPC. This is the NPC's unique identifier (ID).
   */
  code: string
  /**
   * Npc
   *
   * Code of the NPC that sells/buys the item.
   */
  npc: string
  /**
   * Currency
   *
   * Currency used to buy/sell the item. If it's not gold, it's the item code.
   */
  currency: string
  /**
   * Buy Price
   *
   * Price to buy the item.
   */
  buy_price?: number
  /**
   * Sell Price
   *
   * Price to sell the item.
   */
  sell_price?: number
}

/**
 * NPCResponseSchema
 */
export interface NpcResponseSchema {
  data: NpcSchema
}

/**
 * NPCSchema
 */
export interface NpcSchema {
  /**
   * Name
   *
   * Name of the NPC.
   */
  name: string
  /**
   * Code
   *
   * The code of the NPC. This is the NPC's unique identifier (ID).
   */
  code: string
  /**
   * Description
   *
   * Description of the NPC.
   */
  description: string
  /**
   * Type of the NPC.
   */
  type: NpcType
}

/**
 * NPCType
 */
export type NpcType = 'merchant' | 'trader'

/**
 * NpcItemTransactionSchema
 */
export interface NpcItemTransactionSchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
  /**
   * Currency
   *
   * Currency used for the transaction.
   */
  currency: string
  /**
   * Price
   *
   * Item price.
   */
  price: number
  /**
   * Total Price
   *
   * Total price of the transaction.
   */
  total_price: number
}

/**
 * NpcMerchantBuySchema
 */
export interface NpcMerchantBuySchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
}

/**
 * NpcMerchantTransactionResponseSchema
 */
export interface NpcMerchantTransactionResponseSchema {
  data: NpcMerchantTransactionSchema
}

/**
 * NpcMerchantTransactionSchema
 */
export interface NpcMerchantTransactionSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Transaction details.
   */
  transaction: NpcItemTransactionSchema
  /**
   * Character details.
   */
  character: CharacterSchema
}

/**
 * PasswordResetConfirmSchema
 */
export interface PasswordResetConfirmSchema {
  /**
   * Token
   *
   * Password reset token.
   */
  token: string
  /**
   * New Password
   *
   * Your new password.
   */
  new_password: string
}

/**
 * PasswordResetRequestSchema
 */
export interface PasswordResetRequestSchema {
  /**
   * Email
   *
   * Your email address.
   */
  email: string
}

/**
 * PasswordResetResponseSchema
 */
export interface PasswordResetResponseSchema {
  /**
   * Message
   *
   * Success message.
   */
  message: string
}

/**
 * RateLimitSchema
 */
export interface RateLimitSchema {
  /**
   * Type
   *
   * Type of rate limit.
   */
  type: string
  /**
   * Value
   *
   * Value of the rate limit.
   */
  value: string
}

/**
 * RecyclingDataSchema
 */
export interface RecyclingDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Craft details.
   */
  details: RecyclingItemsSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * RecyclingItemsSchema
 */
export interface RecyclingItemsSchema {
  /**
   * Items
   *
   * Objects received.
   */
  items: DropSchema[]
}

/**
 * RecyclingResponseSchema
 */
export interface RecyclingResponseSchema {
  data: RecyclingDataSchema
}

/**
 * RecyclingSchema
 */
export interface RecyclingSchema {
  /**
   * Item code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Quantity of items to recycle.
   */
  quantity?: number
}

/**
 * ResourceResponseSchema
 */
export interface ResourceResponseSchema {
  data: ResourceSchema
}

/**
 * ResourceSchema
 */
export interface ResourceSchema {
  /**
   * Name
   *
   * The name of the resource
   */
  name: string
  /**
   * Code
   *
   * The code of the resource. This is the resource's unique identifier (ID).
   */
  code: string
  /**
   * Skill code
   *
   * The skill required to gather this resource.
   */
  skill: GatheringSkill
  /**
   * Level
   *
   * The skill level required to gather this resource.
   */
  level: number
  /**
   * Drops
   *
   * The drops of this resource.
   */
  drops: DropRateSchema[]
}

/**
 * ResponseSchema
 */
export interface ResponseSchema {
  /**
   * Message
   */
  message: string
}

/**
 * RewardDataResponseSchema
 */
export interface RewardDataResponseSchema {
  data: RewardDataSchema
}

/**
 * RewardDataSchema
 */
export interface RewardDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Reward details.
   */
  rewards: RewardsSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * RewardResponseSchema
 */
export interface RewardResponseSchema {
  data: DropRateSchema
}

/**
 * RewardsSchema
 */
export interface RewardsSchema {
  /**
   * Items
   *
   * Items rewards.
   */
  items: SimpleItemSchema[]
  /**
   * Gold
   *
   * Gold rewards.
   */
  gold: number
}

/**
 * SeasonBadgeSchema
 */
export interface SeasonBadgeSchema {
  /**
   * Code
   *
   * Badge code.
   */
  code: string
  /**
   * Description
   *
   * Badge description.
   */
  description: string
  /**
   * Required Points
   *
   * Required achievement points to earn the badge.
   */
  required_points: number
}

/**
 * SeasonSchema
 */
export interface SeasonSchema {
  /**
   * Name
   *
   * Season name.
   */
  name?: string
  /**
   * Number
   *
   * Season number.
   */
  number?: number
  /**
   * Start Date
   *
   * Season start date.
   */
  start_date?: string
  /**
   * Badges
   *
   * Season badges with required achievement points.
   */
  badges: SeasonBadgeSchema[]
  /**
   * Skins
   *
   * Season skins with required achievement points.
   */
  skins: SeasonSkinSchema[]
}

/**
 * SeasonSkinSchema
 */
export interface SeasonSkinSchema {
  /**
   * Code
   *
   * Skin code.
   */
  code: string
  /**
   * Description
   *
   * Skin description.
   */
  description: string
  /**
   * Required Points
   *
   * Required achievement points to earn the skin.
   */
  required_points: number
}

/**
 * SimpleEffectSchema
 */
export interface SimpleEffectSchema {
  /**
   * Code
   *
   * Effect code.
   */
  code: string
  /**
   * Value
   *
   * Effect value.
   */
  value: number
  /**
   * Description
   *
   * Description of the effect.
   */
  description: string
}

/**
 * SimpleItemSchema
 */
export interface SimpleItemSchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
}

/**
 * Skill
 */
export type Skill =
  | 'weaponcrafting'
  | 'gearcrafting'
  | 'jewelrycrafting'
  | 'cooking'
  | 'woodcutting'
  | 'mining'
  | 'alchemy'
  | 'fishing'

/**
 * SkillDataSchema
 */
export interface SkillDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Craft details.
   */
  details: SkillInfoSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * SkillInfoSchema
 */
export interface SkillInfoSchema {
  /**
   * Xp
   *
   * The amount of xp gained.
   */
  xp: number
  /**
   * Items
   *
   * Objects received.
   */
  items: DropSchema[]
}

/**
 * SkillResponseSchema
 */
export interface SkillResponseSchema {
  data: SkillDataSchema
}

/**
 * SpawnEventRequest
 *
 * Model for the request to spawn a specific event
 */
export interface SpawnEventRequest {
  /**
   * Code
   *
   * Code of the event to spawn
   */
  code: string
}

/**
 * StatusResponseSchema
 */
export interface StatusResponseSchema {
  data: StatusSchema
}

/**
 * StatusSchema
 */
export interface StatusSchema {
  /**
   * Version
   *
   * Game version.
   */
  version: string
  /**
   * Server Time
   *
   * Server time.
   */
  server_time: string
  /**
   * Max Level
   *
   * Maximum level.
   */
  max_level: number
  /**
   * Max Skill Level
   *
   * Maximum skill level.
   */
  max_skill_level: number
  /**
   * Characters Online
   *
   * Characters online.
   */
  characters_online: number
  /**
   * Current season details.
   */
  season?: SeasonSchema
  /**
   * Rate Limits
   *
   * Rate limits.
   */
  rate_limits: RateLimitSchema[]
}

/**
 * StorageEffectSchema
 */
export interface StorageEffectSchema {
  /**
   * Code
   *
   * Effect code.
   */
  code: string
  /**
   * Value
   *
   * Effect value.
   */
  value: number
}

/**
 * TaskCancelledResponseSchema
 */
export interface TaskCancelledResponseSchema {
  data: TaskCancelledSchema
}

/**
 * TaskCancelledSchema
 */
export interface TaskCancelledSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * TaskDataSchema
 */
export interface TaskDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Task details.
   */
  task: TaskSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * TaskFullResponseSchema
 */
export interface TaskFullResponseSchema {
  data: TaskFullSchema
}

/**
 * TaskFullSchema
 */
export interface TaskFullSchema {
  /**
   * Code
   *
   * Task objective.
   */
  code: string
  /**
   * Level
   *
   * Task level.
   */
  level: number
  /**
   * Type
   *
   * The type of task.
   */
  type: TaskType
  /**
   * Min Quantity
   *
   * Minimum amount of task.
   */
  min_quantity: number
  /**
   * Max Quantity
   *
   * Maximum amount of task.
   */
  max_quantity: number
  /**
   * Skill
   *
   * Skill required to complete the task.
   */
  skill?: string
  /**
   * Rewards.
   */
  rewards: RewardsSchema
}

/**
 * TaskResponseSchema
 */
export interface TaskResponseSchema {
  data: TaskDataSchema
}

/**
 * TaskSchema
 */
export interface TaskSchema {
  /**
   * Code
   *
   * Task objective.
   */
  code: string
  /**
   * Type
   *
   * The type of task.
   */
  type: TaskType
  /**
   * Total
   *
   * The total required to complete the task.
   */
  total: number
  /**
   * Rewards for completing the task.
   */
  rewards: RewardsSchema
}

/**
 * TaskTradeDataSchema
 */
export interface TaskTradeDataSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Reward details.
   */
  trade: TaskTradeSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * TaskTradeResponseSchema
 */
export interface TaskTradeResponseSchema {
  data: TaskTradeDataSchema
}

/**
 * TaskTradeSchema
 */
export interface TaskTradeSchema {
  /**
   * Code
   *
   * Item code.
   */
  code: string
  /**
   * Quantity
   *
   * Item quantity.
   */
  quantity: number
}

/**
 * TaskType
 */
export type TaskType = 'monsters' | 'items'

/**
 * TokenResponseSchema
 */
export interface TokenResponseSchema {
  /**
   * Token
   */
  token: string
}

/**
 * TransitionSchema
 */
export interface TransitionSchema {
  /**
   * Map Id
   *
   * ID of the destination map.
   */
  map_id: number
  /**
   * X
   *
   * Position X of the destination.
   */
  x: number
  /**
   * Y
   *
   * Position Y of the destination.
   */
  y: number
  /**
   * Layer of the destination.
   */
  layer: MapLayer
  /**
   * Conditions
   *
   * Conditions for the transition.
   */
  conditions?: ConditionSchema[]
}

/**
 * UnequipSchema
 */
export interface UnequipSchema {
  /**
   * Item slot.
   */
  slot: ItemSlot
  /**
   * Quantity
   *
   * Item quantity. Applicable to utilities only.
   */
  quantity?: number
}

/**
 * UseItemResponseSchema
 */
export interface UseItemResponseSchema {
  data: UseItemSchema
}

/**
 * UseItemSchema
 */
export interface UseItemSchema {
  /**
   * Cooldown details.
   */
  cooldown: CooldownSchema
  /**
   * Item details.
   */
  item: ItemSchema
  /**
   * Player details.
   */
  character: CharacterSchema
}

/**
 * ValidationError
 */
export interface ValidationError {
  /**
   * Location
   */
  loc: (string | number)[]
  /**
   * Message
   */
  msg: string
  /**
   * Error Type
   */
  type: string
}

export interface ErrorSchema {
  /**
   * Error code
   */
  code: number
  /**
   * Error message
   */
  message: string
  /**
   * Additional error data (used primarily for validation errors)
   */
  data?: Record<string, unknown>
}

export interface ErrorResponseSchema {
  error: ErrorSchema
}

export interface GetServerDetailsGetData {
  body?: never
  path?: never
  query?: never
  url: '/'
}

export interface GetServerDetailsGetResponses {
  /**
   * Successfully fetched status.
   */
  200: StatusResponseSchema
}

export type GetServerDetailsGetResponse = GetServerDetailsGetResponses[keyof GetServerDetailsGetResponses]

export interface GetBankDetailsMyBankGetData {
  body?: never
  path?: never
  query?: never
  url: '/my/bank'
}

export interface GetBankDetailsMyBankGetResponses {
  /**
   * Successfully fetched bank details.
   */
  200: BankResponseSchema
}

export type GetBankDetailsMyBankGetResponse = GetBankDetailsMyBankGetResponses[keyof GetBankDetailsMyBankGetResponses]

export interface GetBankItemsMyBankItemsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Item code
     *
     * Item to search in your bank.
     */
    item_code?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/my/bank/items'
}

export interface GetBankItemsMyBankItemsGetResponses {
  /**
   * Successfully fetched data.
   */
  200: DataPageSimpleItemSchema
}

export type GetBankItemsMyBankItemsGetResponse =
  GetBankItemsMyBankItemsGetResponses[keyof GetBankItemsMyBankItemsGetResponses]

export interface GetGeSellOrdersMyGrandexchangeOrdersGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Item code
     *
     * The code of the item.
     */
    code?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/my/grandexchange/orders'
}

export interface GetGeSellOrdersMyGrandexchangeOrdersGetResponses {
  /**
   * Successfully fetched data.
   */
  200: DataPageGeOrderSchema
}

export type GetGeSellOrdersMyGrandexchangeOrdersGetResponse =
  GetGeSellOrdersMyGrandexchangeOrdersGetResponses[keyof GetGeSellOrdersMyGrandexchangeOrdersGetResponses]

export interface GetGeSellHistoryMyGrandexchangeHistoryGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Order ID
     *
     * Order ID to search in your history.
     */
    id?: string
    /**
     * Item code
     *
     * Item to search in your history.
     */
    code?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/my/grandexchange/history'
}

export interface GetGeSellHistoryMyGrandexchangeHistoryGetResponses {
  /**
   * Successfully fetched data.
   */
  200: DataPageGeOrderHistorySchema
}

export type GetGeSellHistoryMyGrandexchangeHistoryGetResponse =
  GetGeSellHistoryMyGrandexchangeHistoryGetResponses[keyof GetGeSellHistoryMyGrandexchangeHistoryGetResponses]

export interface GetAccountDetailsMyDetailsGetData {
  body?: never
  path?: never
  query?: never
  url: '/my/details'
}

export interface GetAccountDetailsMyDetailsGetResponses {
  /**
   * Successfully fetched data.
   */
  200: MyAccountDetailsSchema
}

export type GetAccountDetailsMyDetailsGetResponse =
  GetAccountDetailsMyDetailsGetResponses[keyof GetAccountDetailsMyDetailsGetResponses]

export interface ChangePasswordMyChangePasswordPostData {
  body: ChangePassword
  path?: never
  query?: never
  url: '/my/change_password'
}

export interface ChangePasswordMyChangePasswordPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Please use a different password.
   */
  458: ErrorResponseSchema
  /**
   * The current password you entered is invalid.
   */
  459: ErrorResponseSchema
}

export type ChangePasswordMyChangePasswordPostError =
  ChangePasswordMyChangePasswordPostErrors[keyof ChangePasswordMyChangePasswordPostErrors]

export interface ChangePasswordMyChangePasswordPostResponses {
  /**
   * Password changed successfully.
   */
  200: ResponseSchema
}

export type ChangePasswordMyChangePasswordPostResponse =
  ChangePasswordMyChangePasswordPostResponses[keyof ChangePasswordMyChangePasswordPostResponses]

export interface ActionMoveMyNameActionMovePostData {
  body: DestinationSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/move'
}

export interface ActionMoveMyNameActionMovePostErrors {
  /**
   * Map not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character is already at the destination.
   */
  490: ErrorResponseSchema
  /**
   * Conditions not met.
   */
  496: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * No path available to the destination map.
   */
  595: ErrorResponseSchema
  /**
   * The map is blocked and cannot be accessed.
   */
  596: ErrorResponseSchema
}

export type ActionMoveMyNameActionMovePostError =
  ActionMoveMyNameActionMovePostErrors[keyof ActionMoveMyNameActionMovePostErrors]

export interface ActionMoveMyNameActionMovePostResponses {
  /**
   * The character has moved successfully.
   */
  200: CharacterMovementResponseSchema
}

export type ActionMoveMyNameActionMovePostResponse =
  ActionMoveMyNameActionMovePostResponses[keyof ActionMoveMyNameActionMovePostResponses]

export interface ActionTransitionMyNameActionTransitionPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/transition'
}

export interface ActionTransitionMyNameActionTransitionPostErrors {
  /**
   * Transition not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Insufficient gold for this transition.
   */
  492: ErrorResponseSchema
  /**
   * Conditions not met.
   */
  496: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionTransitionMyNameActionTransitionPostError =
  ActionTransitionMyNameActionTransitionPostErrors[keyof ActionTransitionMyNameActionTransitionPostErrors]

export interface ActionTransitionMyNameActionTransitionPostResponses {
  /**
   * The character has transitioned successfully.
   */
  200: CharacterTransitionResponseSchema
}

export type ActionTransitionMyNameActionTransitionPostResponse =
  ActionTransitionMyNameActionTransitionPostResponses[keyof ActionTransitionMyNameActionTransitionPostResponses]

export interface ActionRestMyNameActionRestPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/rest'
}

export interface ActionRestMyNameActionRestPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionRestMyNameActionRestPostError =
  ActionRestMyNameActionRestPostErrors[keyof ActionRestMyNameActionRestPostErrors]

export interface ActionRestMyNameActionRestPostResponses {
  /**
   * The character has rested successfully.
   */
  200: CharacterRestResponseSchema
}

export type ActionRestMyNameActionRestPostResponse =
  ActionRestMyNameActionRestPostResponses[keyof ActionRestMyNameActionRestPostResponses]

export interface ActionEquipItemMyNameActionEquipPostData {
  body: EquipSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/equip'
}

export interface ActionEquipItemMyNameActionEquipPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * The character does not have enough HP to unequip this item.
   */
  483: ErrorResponseSchema
  /**
   * The character cannot equip more than 100 utilities in the same slot.
   */
  484: ErrorResponseSchema
  /**
   * This item is already equipped.
   */
  485: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The equipment slot is not empty.
   */
  491: ErrorResponseSchema
  /**
   * Conditions not met.
   */
  496: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionEquipItemMyNameActionEquipPostError =
  ActionEquipItemMyNameActionEquipPostErrors[keyof ActionEquipItemMyNameActionEquipPostErrors]

export interface ActionEquipItemMyNameActionEquipPostResponses {
  /**
   * The item has been successfully equipped on your character.
   */
  200: EquipmentResponseSchema
}

export type ActionEquipItemMyNameActionEquipPostResponse =
  ActionEquipItemMyNameActionEquipPostResponses[keyof ActionEquipItemMyNameActionEquipPostResponses]

export interface ActionUnequipItemMyNameActionUnequipPostData {
  body: UnequipSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/unequip'
}

export interface ActionUnequipItemMyNameActionUnequipPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * The character does not have enough HP to unequip this item.
   */
  483: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The equipment slot is empty.
   */
  491: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionUnequipItemMyNameActionUnequipPostError =
  ActionUnequipItemMyNameActionUnequipPostErrors[keyof ActionUnequipItemMyNameActionUnequipPostErrors]

export interface ActionUnequipItemMyNameActionUnequipPostResponses {
  /**
   * The item has been successfully unequipped and added in their inventory.
   */
  200: EquipmentResponseSchema
}

export type ActionUnequipItemMyNameActionUnequipPostResponse =
  ActionUnequipItemMyNameActionUnequipPostResponses[keyof ActionUnequipItemMyNameActionUnequipPostResponses]

export interface ActionUseItemMyNameActionUsePostData {
  body: SimpleItemSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/use'
}

export interface ActionUseItemMyNameActionUsePostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This item is not a consumable.
   */
  476: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Conditions not met.
   */
  496: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionUseItemMyNameActionUsePostError =
  ActionUseItemMyNameActionUsePostErrors[keyof ActionUseItemMyNameActionUsePostErrors]

export interface ActionUseItemMyNameActionUsePostResponses {
  /**
   * The item has been successfully used.
   */
  200: UseItemResponseSchema
}

export type ActionUseItemMyNameActionUsePostResponse =
  ActionUseItemMyNameActionUsePostResponses[keyof ActionUseItemMyNameActionUsePostResponses]

export interface ActionFightMyNameActionFightPostData {
  /**
   * Fight Request
   */
  body?: FightRequestSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/fight'
}

export interface ActionFightMyNameActionFightPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Only boss monsters can be fought by multiple characters.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Monster not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionFightMyNameActionFightPostError =
  ActionFightMyNameActionFightPostErrors[keyof ActionFightMyNameActionFightPostErrors]

export interface ActionFightMyNameActionFightPostResponses {
  /**
   * The fight ended successfully.
   */
  200: CharacterFightResponseSchema
}

export type ActionFightMyNameActionFightPostResponse =
  ActionFightMyNameActionFightPostResponses[keyof ActionFightMyNameActionFightPostResponses]

export interface ActionGatheringMyNameActionGatheringPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/gathering'
}

export interface ActionGatheringMyNameActionGatheringPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's skill level is too low.
   */
  493: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Resource not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionGatheringMyNameActionGatheringPostError =
  ActionGatheringMyNameActionGatheringPostErrors[keyof ActionGatheringMyNameActionGatheringPostErrors]

export interface ActionGatheringMyNameActionGatheringPostResponses {
  /**
   * The resource has been successfully gathered.
   */
  200: SkillResponseSchema
}

export type ActionGatheringMyNameActionGatheringPostResponse =
  ActionGatheringMyNameActionGatheringPostResponses[keyof ActionGatheringMyNameActionGatheringPostResponses]

export interface ActionCraftingMyNameActionCraftingPostData {
  body: CraftingSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/crafting'
}

export interface ActionCraftingMyNameActionCraftingPostErrors {
  /**
   * Craft not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's skill level is too low.
   */
  493: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Workshop not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionCraftingMyNameActionCraftingPostError =
  ActionCraftingMyNameActionCraftingPostErrors[keyof ActionCraftingMyNameActionCraftingPostErrors]

export interface ActionCraftingMyNameActionCraftingPostResponses {
  /**
   * The item was successfully crafted.
   */
  200: SkillResponseSchema
}

export type ActionCraftingMyNameActionCraftingPostResponse =
  ActionCraftingMyNameActionCraftingPostResponses[keyof ActionCraftingMyNameActionCraftingPostResponses]

export interface ActionDepositBankGoldMyNameActionBankDepositGoldPostData {
  body: DepositWithdrawGoldSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/bank/deposit/gold'
}

export interface ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Some of your items or your gold in the bank are already part of an ongoing transaction.
   */
  461: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Bank not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostError =
  ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors[keyof ActionDepositBankGoldMyNameActionBankDepositGoldPostErrors]

export interface ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses {
  /**
   * Golds successfully deposited in your bank.
   */
  200: BankGoldTransactionResponseSchema
}

export type ActionDepositBankGoldMyNameActionBankDepositGoldPostResponse =
  ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses[keyof ActionDepositBankGoldMyNameActionBankDepositGoldPostResponses]

export interface ActionDepositBankItemMyNameActionBankDepositItemPostData {
  /**
   * Items
   *
   * List of items to deposit in the bank.
   */
  body: SimpleItemSchema[]
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/bank/deposit/item'
}

export interface ActionDepositBankItemMyNameActionBankDepositItemPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Some of your items or your gold in the bank are already part of an ongoing transaction.
   */
  461: ErrorResponseSchema
  /**
   * Your bank is full.
   */
  462: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Bank not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionDepositBankItemMyNameActionBankDepositItemPostError =
  ActionDepositBankItemMyNameActionBankDepositItemPostErrors[keyof ActionDepositBankItemMyNameActionBankDepositItemPostErrors]

export interface ActionDepositBankItemMyNameActionBankDepositItemPostResponses {
  /**
   * Items successfully deposited in your bank.
   */
  200: BankItemTransactionResponseSchema
}

export type ActionDepositBankItemMyNameActionBankDepositItemPostResponse =
  ActionDepositBankItemMyNameActionBankDepositItemPostResponses[keyof ActionDepositBankItemMyNameActionBankDepositItemPostResponses]

export interface ActionWithdrawBankItemMyNameActionBankWithdrawItemPostData {
  /**
   * Items
   */
  body: SimpleItemSchema[]
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/bank/withdraw/item'
}

export interface ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Some of your items or your gold in the bank are already part of an ongoing transaction.
   */
  461: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Bank not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostError =
  ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors[keyof ActionWithdrawBankItemMyNameActionBankWithdrawItemPostErrors]

export interface ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses {
  /**
   * Items successfully withdrawn from your bank.
   */
  200: BankItemTransactionResponseSchema
}

export type ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponse =
  ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses[keyof ActionWithdrawBankItemMyNameActionBankWithdrawItemPostResponses]

export interface ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostData {
  body: DepositWithdrawGoldSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/bank/withdraw/gold'
}

export interface ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Insufficient gold in your bank.
   */
  460: ErrorResponseSchema
  /**
   * Some of your items or your gold in the bank are already part of an ongoing transaction.
   */
  461: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Bank not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError =
  ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors[keyof ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostErrors]

export interface ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses {
  /**
   * Golds successfully withdraw from your bank.
   */
  200: BankGoldTransactionResponseSchema
}

export type ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponse =
  ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses[keyof ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponses]

export interface ActionBuyBankExpansionMyNameActionBankBuyExpansionPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/bank/buy_expansion'
}

export interface ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Bank not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError =
  ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors[keyof ActionBuyBankExpansionMyNameActionBankBuyExpansionPostErrors]

export interface ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses {
  /**
   * Bank expansion successfully bought.
   */
  200: BankExtensionTransactionResponseSchema
}

export type ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponse =
  ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses[keyof ActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponses]

export interface ActionNpcBuyItemMyNameActionNpcBuyPostData {
  body: NpcMerchantBuySchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/npc/buy'
}

export interface ActionNpcBuyItemMyNameActionNpcBuyPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This item is not available for purchase.
   */
  441: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * NPC not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionNpcBuyItemMyNameActionNpcBuyPostError =
  ActionNpcBuyItemMyNameActionNpcBuyPostErrors[keyof ActionNpcBuyItemMyNameActionNpcBuyPostErrors]

export interface ActionNpcBuyItemMyNameActionNpcBuyPostResponses {
  /**
   * Item successfully bought from the NPC.
   */
  200: NpcMerchantTransactionResponseSchema
}

export type ActionNpcBuyItemMyNameActionNpcBuyPostResponse =
  ActionNpcBuyItemMyNameActionNpcBuyPostResponses[keyof ActionNpcBuyItemMyNameActionNpcBuyPostResponses]

export interface ActionNpcSellItemMyNameActionNpcSellPostData {
  body: NpcMerchantBuySchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/npc/sell'
}

export interface ActionNpcSellItemMyNameActionNpcSellPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This item cannot be sold.
   */
  442: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * NPC not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionNpcSellItemMyNameActionNpcSellPostError =
  ActionNpcSellItemMyNameActionNpcSellPostErrors[keyof ActionNpcSellItemMyNameActionNpcSellPostErrors]

export interface ActionNpcSellItemMyNameActionNpcSellPostResponses {
  /**
   * Item successfully sold to the NPC.
   */
  200: NpcMerchantTransactionResponseSchema
}

export type ActionNpcSellItemMyNameActionNpcSellPostResponse =
  ActionNpcSellItemMyNameActionNpcSellPostResponses[keyof ActionNpcSellItemMyNameActionNpcSellPostResponses]

export interface ActionRecyclingMyNameActionRecyclingPostData {
  body: RecyclingSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/recycling'
}

export interface ActionRecyclingMyNameActionRecyclingPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This item cannot be recycled.
   */
  473: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's skill level is too low.
   */
  493: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Workshop not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionRecyclingMyNameActionRecyclingPostError =
  ActionRecyclingMyNameActionRecyclingPostErrors[keyof ActionRecyclingMyNameActionRecyclingPostErrors]

export interface ActionRecyclingMyNameActionRecyclingPostResponses {
  /**
   * The items were successfully recycled.
   */
  200: RecyclingResponseSchema
}

export type ActionRecyclingMyNameActionRecyclingPostResponse =
  ActionRecyclingMyNameActionRecyclingPostResponses[keyof ActionRecyclingMyNameActionRecyclingPostResponses]

export interface ActionGeBuyItemMyNameActionGrandexchangeBuyPostData {
  body: GeBuyOrderSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/grandexchange/buy'
}

export interface ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors {
  /**
   * Order not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This offer does not contain that many items.
   */
  434: ErrorResponseSchema
  /**
   * You cannot trade with yourself.
   */
  435: ErrorResponseSchema
  /**
   * A transaction is already in progress for this order by another character.
   */
  436: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Grand Exchange not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostError =
  ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors[keyof ActionGeBuyItemMyNameActionGrandexchangeBuyPostErrors]

export interface ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses {
  /**
   * Item successfully bought from the Grand Exchange.
   */
  200: GeTransactionResponseSchema
}

export type ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponse =
  ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses[keyof ActionGeBuyItemMyNameActionGrandexchangeBuyPostResponses]

export interface ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostData {
  body: GeOrderCreationrSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/grandexchange/sell'
}

export interface ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * You cannot create more than 100 orders at the same time.
   */
  433: ErrorResponseSchema
  /**
   * This item cannot be sold.
   */
  437: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Grand Exchange not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError =
  ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors[keyof ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostErrors]

export interface ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses {
  /**
   * The sell order has been successfully created.
   */
  200: GeCreateOrderTransactionResponseSchema
}

export type ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponse =
  ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses[keyof ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponses]

export interface ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostData {
  body: GeCancelOrderSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/grandexchange/cancel'
}

export interface ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors {
  /**
   * Order not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * A transaction is already in progress for this order by another character.
   */
  436: ErrorResponseSchema
  /**
   * You cannot cancel an order that is not yours.
   */
  438: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Grand Exchange not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError =
  ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors[keyof ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostErrors]

export interface ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses {
  /**
   * Your sell order has been successfully cancelled.
   */
  200: GeTransactionResponseSchema
}

export type ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponse =
  ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses[keyof ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponses]

export interface ActionCompleteTaskMyNameActionTaskCompletePostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/task/complete'
}

export interface ActionCompleteTaskMyNameActionTaskCompletePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character has no task assigned.
   */
  487: ErrorResponseSchema
  /**
   * The character has not completed the task.
   */
  488: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Tasks Master not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionCompleteTaskMyNameActionTaskCompletePostError =
  ActionCompleteTaskMyNameActionTaskCompletePostErrors[keyof ActionCompleteTaskMyNameActionTaskCompletePostErrors]

export interface ActionCompleteTaskMyNameActionTaskCompletePostResponses {
  /**
   * The task has been successfully completed.
   */
  200: RewardDataResponseSchema
}

export type ActionCompleteTaskMyNameActionTaskCompletePostResponse =
  ActionCompleteTaskMyNameActionTaskCompletePostResponses[keyof ActionCompleteTaskMyNameActionTaskCompletePostResponses]

export interface ActionTaskExchangeMyNameActionTaskExchangePostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/task/exchange'
}

export interface ActionTaskExchangeMyNameActionTaskExchangePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Tasks Master not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionTaskExchangeMyNameActionTaskExchangePostError =
  ActionTaskExchangeMyNameActionTaskExchangePostErrors[keyof ActionTaskExchangeMyNameActionTaskExchangePostErrors]

export interface ActionTaskExchangeMyNameActionTaskExchangePostResponses {
  /**
   * The tasks coins have been successfully exchanged.
   */
  200: RewardDataResponseSchema
}

export type ActionTaskExchangeMyNameActionTaskExchangePostResponse =
  ActionTaskExchangeMyNameActionTaskExchangePostResponses[keyof ActionTaskExchangeMyNameActionTaskExchangePostResponses]

export interface ActionAcceptNewTaskMyNameActionTaskNewPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/task/new'
}

export interface ActionAcceptNewTaskMyNameActionTaskNewPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character already has an assigned task.
   */
  489: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Tasks Master not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionAcceptNewTaskMyNameActionTaskNewPostError =
  ActionAcceptNewTaskMyNameActionTaskNewPostErrors[keyof ActionAcceptNewTaskMyNameActionTaskNewPostErrors]

export interface ActionAcceptNewTaskMyNameActionTaskNewPostResponses {
  /**
   * New task successfully accepted.
   */
  200: TaskResponseSchema
}

export type ActionAcceptNewTaskMyNameActionTaskNewPostResponse =
  ActionAcceptNewTaskMyNameActionTaskNewPostResponses[keyof ActionAcceptNewTaskMyNameActionTaskNewPostResponses]

export interface ActionTaskTradeMyNameActionTaskTradePostData {
  body: SimpleItemSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/task/trade'
}

export interface ActionTaskTradeMyNameActionTaskTradePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * The character does not have this task.
   */
  474: ErrorResponseSchema
  /**
   * Task already completed or too many items submitted.
   */
  475: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Tasks Master not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionTaskTradeMyNameActionTaskTradePostError =
  ActionTaskTradeMyNameActionTaskTradePostErrors[keyof ActionTaskTradeMyNameActionTaskTradePostErrors]

export interface ActionTaskTradeMyNameActionTaskTradePostResponses {
  /**
   * You have successfully trade items to a Tasks Master.
   */
  200: TaskTradeResponseSchema
}

export type ActionTaskTradeMyNameActionTaskTradePostResponse =
  ActionTaskTradeMyNameActionTaskTradePostResponses[keyof ActionTaskTradeMyNameActionTaskTradePostResponses]

export interface ActionTaskCancelMyNameActionTaskCancelPostData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/task/cancel'
}

export interface ActionTaskCancelMyNameActionTaskCancelPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * Tasks Master not found on this map.
   */
  598: ErrorResponseSchema
}

export type ActionTaskCancelMyNameActionTaskCancelPostError =
  ActionTaskCancelMyNameActionTaskCancelPostErrors[keyof ActionTaskCancelMyNameActionTaskCancelPostErrors]

export interface ActionTaskCancelMyNameActionTaskCancelPostResponses {
  /**
   * The task has been successfully cancelled.
   */
  200: TaskCancelledResponseSchema
}

export type ActionTaskCancelMyNameActionTaskCancelPostResponse =
  ActionTaskCancelMyNameActionTaskCancelPostResponses[keyof ActionTaskCancelMyNameActionTaskCancelPostResponses]

export interface ActionGiveGoldMyNameActionGiveGoldPostData {
  body: GiveGoldSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/give/gold'
}

export interface ActionGiveGoldMyNameActionGiveGoldPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character does not have enough gold.
   */
  492: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionGiveGoldMyNameActionGiveGoldPostError =
  ActionGiveGoldMyNameActionGiveGoldPostErrors[keyof ActionGiveGoldMyNameActionGiveGoldPostErrors]

export interface ActionGiveGoldMyNameActionGiveGoldPostResponses {
  /**
   * Gold given successfully.
   */
  200: GiveGoldResponseSchema
}

export type ActionGiveGoldMyNameActionGiveGoldPostResponse =
  ActionGiveGoldMyNameActionGiveGoldPostResponses[keyof ActionGiveGoldMyNameActionGiveGoldPostResponses]

export interface ActionGiveItemsMyNameActionGiveItemPostData {
  body: GiveItemsSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/give/item'
}

export interface ActionGiveItemsMyNameActionGiveItemPostErrors {
  /**
   * Item not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character's inventory is full.
   */
  497: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionGiveItemsMyNameActionGiveItemPostError =
  ActionGiveItemsMyNameActionGiveItemPostErrors[keyof ActionGiveItemsMyNameActionGiveItemPostErrors]

export interface ActionGiveItemsMyNameActionGiveItemPostResponses {
  /**
   * Items given successfully.
   */
  200: GiveItemResponseSchema
}

export type ActionGiveItemsMyNameActionGiveItemPostResponse =
  ActionGiveItemsMyNameActionGiveItemPostResponses[keyof ActionGiveItemsMyNameActionGiveItemPostResponses]

export interface ActionDeleteItemMyNameActionDeletePostData {
  body: SimpleItemSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/delete'
}

export interface ActionDeleteItemMyNameActionDeletePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Missing required item(s).
   */
  478: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
}

export type ActionDeleteItemMyNameActionDeletePostError =
  ActionDeleteItemMyNameActionDeletePostErrors[keyof ActionDeleteItemMyNameActionDeletePostErrors]

export interface ActionDeleteItemMyNameActionDeletePostResponses {
  /**
   * Item successfully deleted from your character.
   */
  200: DeleteItemResponseSchema
}

export type ActionDeleteItemMyNameActionDeletePostResponse =
  ActionDeleteItemMyNameActionDeletePostResponses[keyof ActionDeleteItemMyNameActionDeletePostResponses]

export interface ActionChangeSkinMyNameActionChangeSkinPostData {
  body: ChangeSkinCharacterSchema
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: never
  url: '/my/{name}/action/change_skin'
}

export interface ActionChangeSkinMyNameActionChangeSkinPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * An action is already in progress for this character.
   */
  486: ErrorResponseSchema
  /**
   * The character is in cooldown.
   */
  499: ErrorResponseSchema
  /**
   * You cannot choose this skin because you do not own it.
   */
  550: ErrorResponseSchema
}

export type ActionChangeSkinMyNameActionChangeSkinPostError =
  ActionChangeSkinMyNameActionChangeSkinPostErrors[keyof ActionChangeSkinMyNameActionChangeSkinPostErrors]

export interface ActionChangeSkinMyNameActionChangeSkinPostResponses {
  /**
   * Skin successfully changed.
   */
  200: ChangeSkinResponseSchema
}

export type ActionChangeSkinMyNameActionChangeSkinPostResponse =
  ActionChangeSkinMyNameActionChangeSkinPostResponses[keyof ActionChangeSkinMyNameActionChangeSkinPostResponses]

export interface GetAllCharactersLogsMyLogsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/my/logs'
}

export interface GetAllCharactersLogsMyLogsGetErrors {
  /**
   * Logs not found.
   */
  404: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
}

export type GetAllCharactersLogsMyLogsGetError =
  GetAllCharactersLogsMyLogsGetErrors[keyof GetAllCharactersLogsMyLogsGetErrors]

export interface GetAllCharactersLogsMyLogsGetResponses {
  /**
   * Successfully fetched logs.
   */
  200: DataPageLogSchema
}

export type GetAllCharactersLogsMyLogsGetResponse =
  GetAllCharactersLogsMyLogsGetResponses[keyof GetAllCharactersLogsMyLogsGetResponses]

export interface GetCharacterLogsMyLogsNameGetData {
  body?: never
  path: {
    /**
     * Character name
     *
     * Name of your character.
     */
    name: string
  }
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/my/logs/{name}'
}

export interface GetCharacterLogsMyLogsNameGetErrors {
  /**
   * Logs not found.
   */
  404: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
}

export type GetCharacterLogsMyLogsNameGetError =
  GetCharacterLogsMyLogsNameGetErrors[keyof GetCharacterLogsMyLogsNameGetErrors]

export interface GetCharacterLogsMyLogsNameGetResponses {
  /**
   * Successfully fetched logs.
   */
  200: DataPageLogSchema
}

export type GetCharacterLogsMyLogsNameGetResponse =
  GetCharacterLogsMyLogsNameGetResponses[keyof GetCharacterLogsMyLogsNameGetResponses]

export interface GetMyCharactersMyCharactersGetData {
  body?: never
  path?: never
  query?: never
  url: '/my/characters'
}

export interface GetMyCharactersMyCharactersGetResponses {
  /**
   * Successfully fetched data.
   */
  200: MyCharactersListSchema
}

export type GetMyCharactersMyCharactersGetResponse =
  GetMyCharactersMyCharactersGetResponses[keyof GetMyCharactersMyCharactersGetResponses]

export interface CreateAccountAccountsCreatePostData {
  body: AddAccountSchema
  path?: never
  query?: never
  url: '/accounts/create'
}

export interface CreateAccountAccountsCreatePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This username is already taken.
   */
  456: ErrorResponseSchema
  /**
   * This email is already in use.
   */
  457: ErrorResponseSchema
}

export type CreateAccountAccountsCreatePostError =
  CreateAccountAccountsCreatePostErrors[keyof CreateAccountAccountsCreatePostErrors]

export interface CreateAccountAccountsCreatePostResponses {
  /**
   * Account created successfully.
   */
  200: ResponseSchema
}

export type CreateAccountAccountsCreatePostResponse =
  CreateAccountAccountsCreatePostResponses[keyof CreateAccountAccountsCreatePostResponses]

export interface ForgotPasswordAccountsForgotPasswordPostData {
  body: PasswordResetRequestSchema
  path?: never
  query?: never
  url: '/accounts/forgot_password'
}

export interface ForgotPasswordAccountsForgotPasswordPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
}

export type ForgotPasswordAccountsForgotPasswordPostError =
  ForgotPasswordAccountsForgotPasswordPostErrors[keyof ForgotPasswordAccountsForgotPasswordPostErrors]

export interface ForgotPasswordAccountsForgotPasswordPostResponses {
  /**
   * If this email address is associated with an account, a reset link has been sent.
   */
  200: PasswordResetResponseSchema
}

export type ForgotPasswordAccountsForgotPasswordPostResponse =
  ForgotPasswordAccountsForgotPasswordPostResponses[keyof ForgotPasswordAccountsForgotPasswordPostResponses]

export interface ResetPasswordAccountsResetPasswordPostData {
  body: PasswordResetConfirmSchema
  path?: never
  query?: never
  url: '/accounts/reset_password'
}

export interface ResetPasswordAccountsResetPasswordPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * The password reset token is invalid.
   */
  560: ErrorResponseSchema
  /**
   * The password reset token has expired.
   */
  561: ErrorResponseSchema
  /**
   * This password reset token has already been used.
   */
  562: ErrorResponseSchema
}

export type ResetPasswordAccountsResetPasswordPostError =
  ResetPasswordAccountsResetPasswordPostErrors[keyof ResetPasswordAccountsResetPasswordPostErrors]

export interface ResetPasswordAccountsResetPasswordPostResponses {
  /**
   * Password has been successfully reset.
   */
  200: PasswordResetResponseSchema
}

export type ResetPasswordAccountsResetPasswordPostResponse =
  ResetPasswordAccountsResetPasswordPostResponses[keyof ResetPasswordAccountsResetPasswordPostResponses]

export interface GetAccountAchievementsAccountsAccountAchievementsGetData {
  body?: never
  path: {
    /**
     * Account name
     *
     * The name of the account.
     */
    account: string
  }
  query?: {
    /**
     * Type
     *
     * Type of achievements.
     */
    type?: AchievementType
    /**
     * Completed
     *
     * Filter by completed achievements.
     */
    completed?: boolean
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/accounts/{account}/achievements'
}

export interface GetAccountAchievementsAccountsAccountAchievementsGetErrors {
  /**
   * Account not found.
   */
  404: ErrorResponseSchema
}

export type GetAccountAchievementsAccountsAccountAchievementsGetError =
  GetAccountAchievementsAccountsAccountAchievementsGetErrors[keyof GetAccountAchievementsAccountsAccountAchievementsGetErrors]

export interface GetAccountAchievementsAccountsAccountAchievementsGetResponses {
  /**
   * Successfully fetched achievements.
   */
  200: DataPageAccountAchievementSchema
}

export type GetAccountAchievementsAccountsAccountAchievementsGetResponse =
  GetAccountAchievementsAccountsAccountAchievementsGetResponses[keyof GetAccountAchievementsAccountsAccountAchievementsGetResponses]

export interface GetAccountCharactersAccountsAccountCharactersGetData {
  body?: never
  path: {
    /**
     * Account name
     *
     * The name of the account.
     */
    account: string
  }
  query?: never
  url: '/accounts/{account}/characters'
}

export interface GetAccountCharactersAccountsAccountCharactersGetResponses {
  /**
   * Successfully fetched account characters.
   */
  200: CharactersListSchema
}

export type GetAccountCharactersAccountsAccountCharactersGetResponse =
  GetAccountCharactersAccountsAccountCharactersGetResponses[keyof GetAccountCharactersAccountsAccountCharactersGetResponses]

export interface GetAccountAccountsAccountGetData {
  body?: never
  path: {
    /**
     * Account name
     *
     * The name of the account.
     */
    account: string
  }
  query?: never
  url: '/accounts/{account}'
}

export interface GetAccountAccountsAccountGetErrors {
  /**
   * account not found.
   */
  404: ErrorResponseSchema
}

export type GetAccountAccountsAccountGetError =
  GetAccountAccountsAccountGetErrors[keyof GetAccountAccountsAccountGetErrors]

export interface GetAccountAccountsAccountGetResponses {
  /**
   * Successfully fetched account.
   */
  200: AccountDetailsSchema
}

export type GetAccountAccountsAccountGetResponse =
  GetAccountAccountsAccountGetResponses[keyof GetAccountAccountsAccountGetResponses]

export interface GetAllAchievementsAchievementsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Type
     *
     * Type of achievements.
     */
    type?: AchievementType
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/achievements'
}

export interface GetAllAchievementsAchievementsGetResponses {
  /**
   * Successfully fetched achievements.
   */
  200: DataPageAchievementSchema
}

export type GetAllAchievementsAchievementsGetResponse =
  GetAllAchievementsAchievementsGetResponses[keyof GetAllAchievementsAchievementsGetResponses]

export interface GetAchievementAchievementsCodeGetData {
  body?: never
  path: {
    /**
     * Achievement code
     *
     * The code of the achievement.
     */
    code: string
  }
  query?: never
  url: '/achievements/{code}'
}

export interface GetAchievementAchievementsCodeGetErrors {
  /**
   * achievement not found.
   */
  404: ErrorResponseSchema
}

export type GetAchievementAchievementsCodeGetError =
  GetAchievementAchievementsCodeGetErrors[keyof GetAchievementAchievementsCodeGetErrors]

export interface GetAchievementAchievementsCodeGetResponses {
  /**
   * Successfully fetched achievement.
   */
  200: AchievementResponseSchema
}

export type GetAchievementAchievementsCodeGetResponse =
  GetAchievementAchievementsCodeGetResponses[keyof GetAchievementAchievementsCodeGetResponses]

export interface GetAllBadgesBadgesGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/badges'
}

export interface GetAllBadgesBadgesGetResponses {
  /**
   * Successfully fetched badges.
   */
  200: DataPageBadgeSchema
}

export type GetAllBadgesBadgesGetResponse = GetAllBadgesBadgesGetResponses[keyof GetAllBadgesBadgesGetResponses]

export interface GetBadgeBadgesCodeGetData {
  body?: never
  path: {
    /**
     * Badge code
     *
     * The code of the badge.
     */
    code: string
  }
  query?: never
  url: '/badges/{code}'
}

export interface GetBadgeBadgesCodeGetErrors {
  /**
   * badge not found.
   */
  404: ErrorResponseSchema
}

export type GetBadgeBadgesCodeGetError = GetBadgeBadgesCodeGetErrors[keyof GetBadgeBadgesCodeGetErrors]

export interface GetBadgeBadgesCodeGetResponses {
  /**
   * Successfully fetched badge.
   */
  200: BadgeResponseSchema
}

export type GetBadgeBadgesCodeGetResponse = GetBadgeBadgesCodeGetResponses[keyof GetBadgeBadgesCodeGetResponses]

export interface CreateCharacterCharactersCreatePostData {
  body: AddCharacterSchema
  path?: never
  query?: never
  url: '/characters/create'
}

export interface CreateCharacterCharactersCreatePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * This name is already in use.
   */
  494: ErrorResponseSchema
  /**
   * You have reached the maximum number of characters on your account.
   */
  495: ErrorResponseSchema
  /**
   * You cannot choose this skin because you do not own it.
   */
  550: ErrorResponseSchema
}

export type CreateCharacterCharactersCreatePostError =
  CreateCharacterCharactersCreatePostErrors[keyof CreateCharacterCharactersCreatePostErrors]

export interface CreateCharacterCharactersCreatePostResponses {
  /**
   * Successfully created character.
   */
  200: CharacterResponseSchema
}

export type CreateCharacterCharactersCreatePostResponse =
  CreateCharacterCharactersCreatePostResponses[keyof CreateCharacterCharactersCreatePostResponses]

export interface DeleteCharacterCharactersDeletePostData {
  body: DeleteCharacterSchema
  path?: never
  query?: never
  url: '/characters/delete'
}

export interface DeleteCharacterCharactersDeletePostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Character not found.
   */
  498: ErrorResponseSchema
}

export type DeleteCharacterCharactersDeletePostError =
  DeleteCharacterCharactersDeletePostErrors[keyof DeleteCharacterCharactersDeletePostErrors]

export interface DeleteCharacterCharactersDeletePostResponses {
  /**
   * Successfully deleted character.
   */
  200: CharacterResponseSchema
}

export type DeleteCharacterCharactersDeletePostResponse =
  DeleteCharacterCharactersDeletePostResponses[keyof DeleteCharacterCharactersDeletePostResponses]

export interface GetActiveCharactersCharactersActiveGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/characters/active'
}

export interface GetActiveCharactersCharactersActiveGetResponses {
  /**
   * Successfully fetched active characters.
   */
  200: DataPageActiveCharacterSchema
}

export type GetActiveCharactersCharactersActiveGetResponse =
  GetActiveCharactersCharactersActiveGetResponses[keyof GetActiveCharactersCharactersActiveGetResponses]

export interface GetCharacterCharactersNameGetData {
  body?: never
  path: {
    /**
     * Character name
     *
     * The name of the character.
     */
    name: string
  }
  query?: never
  url: '/characters/{name}'
}

export interface GetCharacterCharactersNameGetErrors {
  /**
   * character not found.
   */
  404: ErrorResponseSchema
}

export type GetCharacterCharactersNameGetError =
  GetCharacterCharactersNameGetErrors[keyof GetCharacterCharactersNameGetErrors]

export interface GetCharacterCharactersNameGetResponses {
  /**
   * Successfully fetched character.
   */
  200: CharacterResponseSchema
}

export type GetCharacterCharactersNameGetResponse =
  GetCharacterCharactersNameGetResponses[keyof GetCharacterCharactersNameGetResponses]

export interface GetAllEffectsEffectsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/effects'
}

export interface GetAllEffectsEffectsGetResponses {
  /**
   * Successfully fetched effects.
   */
  200: DataPageEffectSchema
}

export type GetAllEffectsEffectsGetResponse = GetAllEffectsEffectsGetResponses[keyof GetAllEffectsEffectsGetResponses]

export interface GetEffectEffectsCodeGetData {
  body?: never
  path: {
    /**
     * Effect code
     *
     * The code of the effect.
     */
    code: string
  }
  query?: never
  url: '/effects/{code}'
}

export interface GetEffectEffectsCodeGetErrors {
  /**
   * effect not found.
   */
  404: ErrorResponseSchema
}

export type GetEffectEffectsCodeGetError = GetEffectEffectsCodeGetErrors[keyof GetEffectEffectsCodeGetErrors]

export interface GetEffectEffectsCodeGetResponses {
  /**
   * Successfully fetched effect.
   */
  200: EffectResponseSchema
}

export type GetEffectEffectsCodeGetResponse = GetEffectEffectsCodeGetResponses[keyof GetEffectEffectsCodeGetResponses]

export interface GetAllActiveEventsEventsActiveGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/events/active'
}

export interface GetAllActiveEventsEventsActiveGetResponses {
  /**
   * Successfully fetched active events.
   */
  200: DataPageActiveEventSchema
}

export type GetAllActiveEventsEventsActiveGetResponse =
  GetAllActiveEventsEventsActiveGetResponses[keyof GetAllActiveEventsEventsActiveGetResponses]

export interface GetAllEventsEventsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Type
     *
     * Type of events.
     */
    type?: MapContentType
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/events'
}

export interface GetAllEventsEventsGetResponses {
  /**
   * Successfully fetched events.
   */
  200: DataPageEventSchema
}

export type GetAllEventsEventsGetResponse = GetAllEventsEventsGetResponses[keyof GetAllEventsEventsGetResponses]

export interface SpawnEventEventsSpawnPostData {
  body: SpawnEventRequest
  path?: never
  query?: never
  url: '/events/spawn'
}

export interface SpawnEventEventsSpawnPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Access denied, you must be a member to do that.
   */
  451: ErrorResponseSchema
  /**
   * Insufficient event tokens. You need at least 1 event token to spawn an event.
   */
  563: ErrorResponseSchema
  /**
   * Event not found or already active.
   */
  564: ErrorResponseSchema
}

export type SpawnEventEventsSpawnPostError = SpawnEventEventsSpawnPostErrors[keyof SpawnEventEventsSpawnPostErrors]

export interface SpawnEventEventsSpawnPostResponses {
  /**
   * Successfully fetched data.
   */
  200: ActiveEventResponseSchema
}

export type SpawnEventEventsSpawnPostResponse =
  SpawnEventEventsSpawnPostResponses[keyof SpawnEventEventsSpawnPostResponses]

export interface GetGeSellHistoryGrandexchangeHistoryCodeGetData {
  body?: never
  path: {
    /**
     * Item code
     *
     * The code of the item.
     */
    code: string
  }
  query?: {
    /**
     * Seller
     *
     * The seller (account name) of the item.
     */
    seller?: string
    /**
     * Buyer
     *
     * The buyer (account name) of the item.
     */
    buyer?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/grandexchange/history/{code}'
}

export interface GetGeSellHistoryGrandexchangeHistoryCodeGetErrors {
  /**
   * item history not found.
   */
  404: ErrorResponseSchema
}

export type GetGeSellHistoryGrandexchangeHistoryCodeGetError =
  GetGeSellHistoryGrandexchangeHistoryCodeGetErrors[keyof GetGeSellHistoryGrandexchangeHistoryCodeGetErrors]

export interface GetGeSellHistoryGrandexchangeHistoryCodeGetResponses {
  /**
   * Successfully fetched item history.
   */
  200: DataPageGeOrderHistorySchema
}

export type GetGeSellHistoryGrandexchangeHistoryCodeGetResponse =
  GetGeSellHistoryGrandexchangeHistoryCodeGetResponses[keyof GetGeSellHistoryGrandexchangeHistoryCodeGetResponses]

export interface GetGeSellOrdersGrandexchangeOrdersGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Item code
     *
     * The code of the item.
     */
    code?: string
    /**
     * Seller
     *
     * The seller (account name) of the item.
     */
    seller?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/grandexchange/orders'
}

export interface GetGeSellOrdersGrandexchangeOrdersGetResponses {
  /**
   * Successfully fetched GE orders.
   */
  200: DataPageGeOrderSchema
}

export type GetGeSellOrdersGrandexchangeOrdersGetResponse =
  GetGeSellOrdersGrandexchangeOrdersGetResponses[keyof GetGeSellOrdersGrandexchangeOrdersGetResponses]

export interface GetGeSellOrderGrandexchangeOrdersIdGetData {
  body?: never
  path: {
    /**
     * Order id
     *
     * The id of the order.
     */
    id: string
  }
  query?: never
  url: '/grandexchange/orders/{id}'
}

export interface GetGeSellOrderGrandexchangeOrdersIdGetErrors {
  /**
   * GE order not found.
   */
  404: ErrorResponseSchema
}

export type GetGeSellOrderGrandexchangeOrdersIdGetError =
  GetGeSellOrderGrandexchangeOrdersIdGetErrors[keyof GetGeSellOrderGrandexchangeOrdersIdGetErrors]

export interface GetGeSellOrderGrandexchangeOrdersIdGetResponses {
  /**
   * Successfully fetched GE order.
   */
  200: GeOrderResponseSchema
}

export type GetGeSellOrderGrandexchangeOrdersIdGetResponse =
  GetGeSellOrderGrandexchangeOrdersIdGetResponses[keyof GetGeSellOrderGrandexchangeOrdersIdGetResponses]

export interface GetAllItemsItemsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Item name
     *
     * Name of the item.
     */
    name?: string
    /**
     * Minimum level
     *
     * Minimum level.
     */
    min_level?: number
    /**
     * Maximum level
     *
     * Maximum level.
     */
    max_level?: number
    /**
     * Type
     *
     * Type of items.
     */
    type?: ItemType
    /**
     * Crafting skill
     *
     * Skill to craft items.
     */
    craft_skill?: CraftSkill
    /**
     * Crafting material
     *
     * Item code of items used as material for crafting.
     */
    craft_material?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/items'
}

export interface GetAllItemsItemsGetResponses {
  /**
   * Successfully fetched items.
   */
  200: DataPageItemSchema
}

export type GetAllItemsItemsGetResponse = GetAllItemsItemsGetResponses[keyof GetAllItemsItemsGetResponses]

export interface GetItemItemsCodeGetData {
  body?: never
  path: {
    /**
     * Item code
     *
     * The code of the item.
     */
    code: string
  }
  query?: never
  url: '/items/{code}'
}

export interface GetItemItemsCodeGetErrors {
  /**
   * item not found.
   */
  404: ErrorResponseSchema
}

export type GetItemItemsCodeGetError = GetItemItemsCodeGetErrors[keyof GetItemItemsCodeGetErrors]

export interface GetItemItemsCodeGetResponses {
  /**
   * Successfully fetched item.
   */
  200: ItemResponseSchema
}

export type GetItemItemsCodeGetResponse = GetItemItemsCodeGetResponses[keyof GetItemItemsCodeGetResponses]

export interface GetCharactersLeaderboardLeaderboardCharactersGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Sort
     *
     * Sort of character leaderboards.
     */
    sort?: CharacterLeaderboardType
    /**
     * Name
     *
     * Character name.
     */
    name?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/leaderboard/characters'
}

export interface GetCharactersLeaderboardLeaderboardCharactersGetResponses {
  /**
   * Successfully fetched leaderboard.
   */
  200: DataPageCharacterLeaderboardSchema
}

export type GetCharactersLeaderboardLeaderboardCharactersGetResponse =
  GetCharactersLeaderboardLeaderboardCharactersGetResponses[keyof GetCharactersLeaderboardLeaderboardCharactersGetResponses]

export interface GetAccountsLeaderboardLeaderboardAccountsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Sort
     *
     * Sort of account leaderboards.
     */
    sort?: AccountLeaderboardType
    /**
     * Name
     *
     * Account name.
     */
    name?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/leaderboard/accounts'
}

export interface GetAccountsLeaderboardLeaderboardAccountsGetResponses {
  /**
   * Successfully fetched leaderboard.
   */
  200: DataPageAccountLeaderboardSchema
}

export type GetAccountsLeaderboardLeaderboardAccountsGetResponse =
  GetAccountsLeaderboardLeaderboardAccountsGetResponses[keyof GetAccountsLeaderboardLeaderboardAccountsGetResponses]

export interface GetAllMapsMapsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Map Layer
     *
     * Filter maps by layer.
     */
    layer?: MapLayer
    /**
     * Map
     *
     * Type of maps.
     */
    content_type?: MapContentType
    /**
     * Content code
     *
     * Content code on the map.
     */
    content_code?: string
    /**
     * Hide blocked maps
     *
     * When true, excludes maps with access_type 'blocked' from the results.
     */
    hide_blocked_maps?: boolean
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/maps'
}

export interface GetAllMapsMapsGetResponses {
  /**
   * Successfully fetched maps.
   */
  200: DataPageMapSchema
}

export type GetAllMapsMapsGetResponse = GetAllMapsMapsGetResponses[keyof GetAllMapsMapsGetResponses]

export interface GetLayerMapsMapsLayerGetData {
  body?: never
  path: {
    /**
     * Map Layer
     *
     * The layer of the map (interior, overworld, underground).
     */
    layer: MapLayer
  }
  query?: {
    /**
     * Map
     *
     * Type of maps.
     */
    content_type?: MapContentType
    /**
     * Content code
     *
     * Content code on the map.
     */
    content_code?: string
    /**
     * Hide blocked maps
     *
     * When true, excludes maps with access_type 'blocked' from the results.
     */
    hide_blocked_maps?: boolean
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/maps/{layer}'
}

export interface GetLayerMapsMapsLayerGetResponses {
  /**
   * Successfully fetched maps.
   */
  200: DataPageMapSchema
}

export type GetLayerMapsMapsLayerGetResponse =
  GetLayerMapsMapsLayerGetResponses[keyof GetLayerMapsMapsLayerGetResponses]

export interface GetMapByPositionMapsLayerXyGetData {
  body?: never
  path: {
    /**
     * Map Layer
     *
     * The layer of the map (interior, overworld, underground).
     */
    layer: MapLayer
    /**
     * Position X
     *
     * The position x of the map.
     */
    x: number
    /**
     * Position Y
     *
     * The position y of the map.
     */
    y: number
  }
  query?: never
  url: '/maps/{layer}/{x}/{y}'
}

export interface GetMapByPositionMapsLayerXyGetErrors {
  /**
   * map not found.
   */
  404: ErrorResponseSchema
}

export type GetMapByPositionMapsLayerXyGetError =
  GetMapByPositionMapsLayerXyGetErrors[keyof GetMapByPositionMapsLayerXyGetErrors]

export interface GetMapByPositionMapsLayerXyGetResponses {
  /**
   * Successfully fetched map.
   */
  200: MapResponseSchema
}

export type GetMapByPositionMapsLayerXyGetResponse =
  GetMapByPositionMapsLayerXyGetResponses[keyof GetMapByPositionMapsLayerXyGetResponses]

export interface GetMapByIdMapsIdMapIdGetData {
  body?: never
  path: {
    /**
     * Map ID
     *
     * The unique ID of the map.
     */
    map_id: number
  }
  query?: never
  url: '/maps/id/{map_id}'
}

export interface GetMapByIdMapsIdMapIdGetErrors {
  /**
   * map not found.
   */
  404: ErrorResponseSchema
}

export type GetMapByIdMapsIdMapIdGetError = GetMapByIdMapsIdMapIdGetErrors[keyof GetMapByIdMapsIdMapIdGetErrors]

export interface GetMapByIdMapsIdMapIdGetResponses {
  /**
   * Successfully fetched map.
   */
  200: MapResponseSchema
}

export type GetMapByIdMapsIdMapIdGetResponse =
  GetMapByIdMapsIdMapIdGetResponses[keyof GetMapByIdMapsIdMapIdGetResponses]

export interface GetAllMonstersMonstersGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Monster name
     *
     * Name of the monster.
     */
    name?: string
    /**
     * Minimum level
     *
     * Minimum level.
     */
    min_level?: number
    /**
     * Maximum level
     *
     * Maximum level.
     */
    max_level?: number
    /**
     * Drop
     *
     * Item code of the drop.
     */
    drop?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/monsters'
}

export interface GetAllMonstersMonstersGetResponses {
  /**
   * Successfully fetched monsters.
   */
  200: DataPageMonsterSchema
}

export type GetAllMonstersMonstersGetResponse =
  GetAllMonstersMonstersGetResponses[keyof GetAllMonstersMonstersGetResponses]

export interface GetMonsterMonstersCodeGetData {
  body?: never
  path: {
    /**
     * Monster code
     *
     * The code of the monster.
     */
    code: string
  }
  query?: never
  url: '/monsters/{code}'
}

export interface GetMonsterMonstersCodeGetErrors {
  /**
   * monster not found.
   */
  404: ErrorResponseSchema
}

export type GetMonsterMonstersCodeGetError = GetMonsterMonstersCodeGetErrors[keyof GetMonsterMonstersCodeGetErrors]

export interface GetMonsterMonstersCodeGetResponses {
  /**
   * Successfully fetched monster.
   */
  200: MonsterResponseSchema
}

export type GetMonsterMonstersCodeGetResponse =
  GetMonsterMonstersCodeGetResponses[keyof GetMonsterMonstersCodeGetResponses]

export interface GetAllNpcsNpcsDetailsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Name
     *
     * NPC name.
     */
    name?: string
    /**
     * Type
     *
     * Type of NPCs.
     */
    type?: NpcType
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/npcs/details'
}

export interface GetAllNpcsNpcsDetailsGetResponses {
  /**
   * Successfully fetched NPCs.
   */
  200: DataPageNpcSchema
}

export type GetAllNpcsNpcsDetailsGetResponse =
  GetAllNpcsNpcsDetailsGetResponses[keyof GetAllNpcsNpcsDetailsGetResponses]

export interface GetNpcNpcsDetailsCodeGetData {
  body?: never
  path: {
    /**
     * Npc code
     *
     * The code of the NPC.
     */
    code: string
  }
  query?: never
  url: '/npcs/details/{code}'
}

export interface GetNpcNpcsDetailsCodeGetErrors {
  /**
   * NPC not found.
   */
  404: ErrorResponseSchema
}

export type GetNpcNpcsDetailsCodeGetError = GetNpcNpcsDetailsCodeGetErrors[keyof GetNpcNpcsDetailsCodeGetErrors]

export interface GetNpcNpcsDetailsCodeGetResponses {
  /**
   * Successfully fetched NPC.
   */
  200: NpcResponseSchema
}

export type GetNpcNpcsDetailsCodeGetResponse =
  GetNpcNpcsDetailsCodeGetResponses[keyof GetNpcNpcsDetailsCodeGetResponses]

export interface GetNpcItemsNpcsItemsCodeGetData {
  body?: never
  path: {
    /**
     * Npc code
     *
     * The code of the NPC.
     */
    code: string
  }
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/npcs/items/{code}'
}

export interface GetNpcItemsNpcsItemsCodeGetErrors {
  /**
   * NPC items not found.
   */
  404: ErrorResponseSchema
}

export type GetNpcItemsNpcsItemsCodeGetError =
  GetNpcItemsNpcsItemsCodeGetErrors[keyof GetNpcItemsNpcsItemsCodeGetErrors]

export interface GetNpcItemsNpcsItemsCodeGetResponses {
  /**
   * Successfully fetched NPC items.
   */
  200: DataPageNpcItem
}

export type GetNpcItemsNpcsItemsCodeGetResponse =
  GetNpcItemsNpcsItemsCodeGetResponses[keyof GetNpcItemsNpcsItemsCodeGetResponses]

export interface GetAllNpcsItemsNpcsItemsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Item code
     *
     * Item code.
     */
    code?: string
    /**
     * NPC code
     *
     * NPC code.
     */
    npc?: string
    /**
     * Currency code
     *
     * Currency code.
     */
    currency?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/npcs/items'
}

export interface GetAllNpcsItemsNpcsItemsGetResponses {
  /**
   * Successfully fetched NPC items.
   */
  200: DataPageNpcItem
}

export type GetAllNpcsItemsNpcsItemsGetResponse =
  GetAllNpcsItemsNpcsItemsGetResponses[keyof GetAllNpcsItemsNpcsItemsGetResponses]

export interface GetAllResourcesResourcesGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Minimum level
     *
     * Minimum level.
     */
    min_level?: number
    /**
     * Maximum level
     *
     * Maximum level.
     */
    max_level?: number
    /**
     * Skill
     *
     * Skill of resources.
     */
    skill?: GatheringSkill
    /**
     * Drop
     *
     * Item code of the drop.
     */
    drop?: string
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/resources'
}

export interface GetAllResourcesResourcesGetResponses {
  /**
   * Successfully fetched resources.
   */
  200: DataPageResourceSchema
}

export type GetAllResourcesResourcesGetResponse =
  GetAllResourcesResourcesGetResponses[keyof GetAllResourcesResourcesGetResponses]

export interface GetResourceResourcesCodeGetData {
  body?: never
  path: {
    /**
     * Resource code
     *
     * The code of the resource.
     */
    code: string
  }
  query?: never
  url: '/resources/{code}'
}

export interface GetResourceResourcesCodeGetErrors {
  /**
   * resource not found.
   */
  404: ErrorResponseSchema
}

export type GetResourceResourcesCodeGetError =
  GetResourceResourcesCodeGetErrors[keyof GetResourceResourcesCodeGetErrors]

export interface GetResourceResourcesCodeGetResponses {
  /**
   * Successfully fetched resource.
   */
  200: ResourceResponseSchema
}

export type GetResourceResourcesCodeGetResponse =
  GetResourceResourcesCodeGetResponses[keyof GetResourceResourcesCodeGetResponses]

export interface GetAllTasksTasksListGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Minimum level
     *
     * Minimum level.
     */
    min_level?: number
    /**
     * Maximum level
     *
     * Maximum level.
     */
    max_level?: number
    /**
     * Skill
     *
     * Skill of tasks.
     */
    skill?: Skill
    /**
     * Type
     *
     * Type of tasks.
     */
    type?: TaskType
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/tasks/list'
}

export interface GetAllTasksTasksListGetResponses {
  /**
   * Successfully fetched tasks.
   */
  200: DataPageTaskFullSchema
}

export type GetAllTasksTasksListGetResponse = GetAllTasksTasksListGetResponses[keyof GetAllTasksTasksListGetResponses]

export interface GetTaskTasksListCodeGetData {
  body?: never
  path: {
    /**
     * Task code
     *
     * The code of the task.
     */
    code: string
  }
  query?: never
  url: '/tasks/list/{code}'
}

export interface GetTaskTasksListCodeGetErrors {
  /**
   * task not found.
   */
  404: ErrorResponseSchema
}

export type GetTaskTasksListCodeGetError = GetTaskTasksListCodeGetErrors[keyof GetTaskTasksListCodeGetErrors]

export interface GetTaskTasksListCodeGetResponses {
  /**
   * Successfully fetched task.
   */
  200: TaskFullResponseSchema
}

export type GetTaskTasksListCodeGetResponse = GetTaskTasksListCodeGetResponses[keyof GetTaskTasksListCodeGetResponses]

export interface GetAllTasksRewardsTasksRewardsGetData {
  body?: never
  path?: never
  query?: {
    /**
     * Page
     *
     * Page number
     */
    page?: number
    /**
     * Size
     *
     * Page size
     */
    size?: number
  }
  url: '/tasks/rewards'
}

export interface GetAllTasksRewardsTasksRewardsGetResponses {
  /**
   * Successfully fetched tasks rewards.
   */
  200: DataPageDropRateSchema
}

export type GetAllTasksRewardsTasksRewardsGetResponse =
  GetAllTasksRewardsTasksRewardsGetResponses[keyof GetAllTasksRewardsTasksRewardsGetResponses]

export interface GetTasksRewardTasksRewardsCodeGetData {
  body?: never
  path: {
    /**
     * Tasks Reward code
     *
     * The code of the tasks reward.
     */
    code: string
  }
  query?: never
  url: '/tasks/rewards/{code}'
}

export interface GetTasksRewardTasksRewardsCodeGetErrors {
  /**
   * tasks reward not found.
   */
  404: ErrorResponseSchema
}

export type GetTasksRewardTasksRewardsCodeGetError =
  GetTasksRewardTasksRewardsCodeGetErrors[keyof GetTasksRewardTasksRewardsCodeGetErrors]

export interface GetTasksRewardTasksRewardsCodeGetResponses {
  /**
   * Successfully fetched tasks reward.
   */
  200: RewardResponseSchema
}

export type GetTasksRewardTasksRewardsCodeGetResponse =
  GetTasksRewardTasksRewardsCodeGetResponses[keyof GetTasksRewardTasksRewardsCodeGetResponses]

export interface FightSimulationSimulationFightSimulationPostData {
  body: CombatSimulationRequestSchema
  path?: never
  query?: never
  url: '/simulation/fight_simulation'
}

export interface FightSimulationSimulationFightSimulationPostErrors {
  /**
   * Monster not found.
   */
  404: ErrorResponseSchema
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Access denied, you must be a member to do that.
   */
  451: ErrorResponseSchema
}

export type FightSimulationSimulationFightSimulationPostError =
  FightSimulationSimulationFightSimulationPostErrors[keyof FightSimulationSimulationFightSimulationPostErrors]

export interface FightSimulationSimulationFightSimulationPostResponses {
  /**
   * Combat simulation completed successfully.
   */
  200: CombatSimulationResponseSchema
}

export type FightSimulationSimulationFightSimulationPostResponse =
  FightSimulationSimulationFightSimulationPostResponses[keyof FightSimulationSimulationFightSimulationPostResponses]

export interface GenerateTokenTokenPostData {
  body?: never
  path?: never
  query?: never
  url: '/token'
}

export interface GenerateTokenTokenPostErrors {
  /**
   * Request could not be processed due to an invalid payload.
   */
  422: ErrorResponseSchema
  /**
   * Failed to generate token.
   */
  455: ErrorResponseSchema
}

export type GenerateTokenTokenPostError = GenerateTokenTokenPostErrors[keyof GenerateTokenTokenPostErrors]

export interface GenerateTokenTokenPostResponses {
  /**
   * Token generated successfully
   */
  200: TokenResponseSchema
}

export type GenerateTokenTokenPostResponse = GenerateTokenTokenPostResponses[keyof GenerateTokenTokenPostResponses]
